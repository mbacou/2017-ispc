---
title: "Agricultural Transformation in Ghana, Ethiopia, and Tanzania"
author: "[BACOU, Melanie](http://github.com/mbacou) for BMGF"
date: "Last updated on `r Sys.Date()` -- CODES AND NOTES, DO NOT USE OR CITE"
description: "Agricultural transformation in Ghana, Tanzania and Ethiopia (ISPC review paper, codes and documentation)"
site: bookdown::bookdown_site
output:bookdown::gitbook:
  url: "https://mbacou.github.io/2017-ispc/"
  github-repo: "mbacou/2017-ispc"
bibliography: biblio.bib
csl: apa.csl
link-ph_s11q03_a + ph_s12q07)citations: yes
nocite: |
  @aasr_2016, @alvarez2014typology, @jayne2015agdev, @hazell2013urban, @douillet2014developing, @jordan2005eth, @omamo2006strategic, @bacou2015ethseg, @omamo2006strategic, @benin2016agricultural, @willy2015adaptation, @jayne2015africafarmland, @diao2017ghana, @roberts2014eth, @schnitzer2014tza, @heady2013ethland, @maxwell2014foodinsec, @minot2013agataeth, @girei2017fadama, @christen2013segmenting, @cgap2017segmentation, @nogales2017sourcebook, @lang2013maps, @nagler2017farms, @seahan2017strikingfacts, @wineman2017migration, @hazell2013urbanization, @anderson2015profiles, @anderson2015transformation, @epar2017segment, @masters2013urban, @hazell2013nutrition, @westat2013productivity, @ispc2013foresight, @headey2010toofast, @estoque2017trends, @odjugo2015benin, @turok2012urban, @lang2013targeting, @nagler2017entrepreneur, @sheahan2017inputs, @buckwell2008biasr, @tnps2016doco, @tnps2014report, @tnps2010report, @ess2014eth, @erss2012eth
  
---

# Data Preparation

```{r setup, include=FALSE}

library(data.table)
library(survey)
library(tmap)
library(knitr)
library(tables)
library(viridis)
library(stringr)
library(raster)

load("../tmp/2017-ispc.RData")

# Output options
table_options(htmloptions(justification="c", head=F, pad=T))
opts_chunk$set(comment=NA, warning=F, message=F, echo=F, base.url="../docs",
  dev="png", fig.path="fig/", fig.width=7, fig.height=3.8, dpi=220, cache=F, 
  dev.args=list(
    png=list(family="Roboto Condensed", pointsize=11), 
    svg=list(family="Roboto Condensed")))

```

```{r ifpri, eval=FALSE}

library(readstata13)
library(foreign)
library(raster)

setwd("~/Projects/2017-ispc")
load("./tmp/2017-ispc.RData")

#####################################################################################
# Helper - default numeric formats
prty <- function(...) prettyNum(..., digits=0, big.mark=",", scientific=FALSE)

# Helper - ggplot defaults
theme_wc <- function(...) theme_bw(base_size=7, base_family="Roboto Condensed", ...) + 
  theme(panel.grid=element_line(linetype="dotted"))

#####################################################################################
# Harmonize income/sales vars across 4 countries and survey years
# Compare crop income/sales with total farm income/sales
# Replicate AGRA-AASR tables with 5 farm types across spatial quadrants

# Load harmonized codebook
lbl <- fread("./data/codebook.csv")
setorder(lbl, secOrder, sortOrder)

# Level lists
quad <- c("agpot-lo / mkt-lo", "agpot-lo / mkt-hi", "agpot-hi / mkt-lo", "agpot-hi / mkt-hi")
load("~/Projects/2017-agra-aasr/tmp/qd.agpot.lbl.rda")

# Load GAEZ raster
rgaez <- raster("~/Maps/GAEZ_res03crav6190lsilrcer/res03_crav6190l_silr_cer (copy).tif")

# Load IFPRI 100K raster
rtt100k <- raster("~/Maps/CELL5M/tt10_SSA_tiff/traveltimetomarket_ssa_100k.tif")

# Make 10km quadrant raster
# GAEZ suitability is coded from 1 to 9:
# 0-no data, 1-very high (> 85%), 2-high (> 70%), 3-good (> 55%), 4-medium (> 40%), 
# 5-moderate (> 25%), 6-marginal (> 10%), 7-very marginal (> 0%), 8-not suitable (0%), 9-water
rquad <- crop(rgaez, rtt100k)*10 + (rtt100k <= 4)
tmp <- c(
  10,10,3, 11,11,4, 20,20,3, 21,21,4, 30,30,3, 31,31,4, 40,40,3, 41,41,4,
  50,50,1, 51,51,2, 60,60,1, 61,61,2, 70,70,1, 71,71,2, 80,80,1, 81,81,2, 90,90,1, 91,91,2)
tmp <- matrix(tmp, ncol=3, byrow=TRUE)
rquad <- reclassify(rquad, tmp, include.lowest=T, right=NA)
hist(rquad)

spplot(rquad, at=0:4, col.regions=viridis(4), 
  colorkey=list(labels=list(labels=quad, at=0:4+.5)))


###############################################
# Import poverty and farm management vars from IFPRI replication datasets (1.2GB)
ifpri <- read.dta13("~/Data/_global_codes/temp/2017.06/Final_SSA_HH_POV_shock_26jun17.dta")

# Drop climate shock vars
ifpri <- data.table(ifpri)[, .SD, .SDcols=c(1:118, 183:212, 651:662)]

# Keep countries of interest
ifpri <- ifpri[ISO3 %in% c("ETH", "GHA", "NGA", "TZA")]
ifpri[, .N, keyby=svyCode]
#    svyCode     N
# 1: eth2010 27835
# 2: gha2012 16772
# 3: nga2012  4536
# 4: tza2012  4878
# => only last waves, but contains poverty, biophysical, land, soc, spei, drought, input
# "tractor"             "draft_animals"      
# "cart_plough"         "improvedseeds"       "orgfert"             "chemfert"           
# "smallagriassets"     "bigagriassets"  
ifpri[, .N, by=farm]
#    farm     N
# 1:    1 24082
# 2:    0 29939


# Load administrative region/district codes (developed for IFPRI)
g2 <- shapefile("~//Data/_global_codes/out/r16.12/svyL2Maps_2016.12.shp")
sort(unique(g2$svyCode))
#  [1] "ago2008" "bdi2006" "bfa2003" "bfa2014" "civ2002" "cmr2007" "cod2012" "eth2010" "eth2012" "gha2005"
# [11] "gha2012" "ken2005" "lso2003" "mdg2005" "mli2006" "mli2014" "moz2008" "mrt2000" "mwi2010" "ner2011"
# [21] "nga2012" "rwa2005" "sen2011" "ssd2009" "tza2012" "uga2012" "uga2013" "zaf2011" "zmb2010"
# => missing tza2010, tza2008, gha2008, do we have maps for these?
# => are admin codes the same in all TZA NPS?
# Keep only ETH and TZA survey maps (bring in GHA survey maps from AGRA-AASR work)
g2 <- g2[g2$ISO3 %in% c("ETH", "TZA"),]
tmp <- shapefile("~/Projects/2017-agra-aasr/maps/svyL2Maps_GHA.shp")
tmp <- tmp[, names(g2)]
g2 <- rbind(g2, tmp)
g2.dt <- data.table(g2@data)
g2.dt[, rn := row.names(g2)]
g2.dt[, unique(svyCode)]
# [1] "tza2012"   "eth2012"   "eth2010"   "gha-glss6" "gha-glss5"
g2.dt[, svyCode := factor(svyCode, 
  levels=c("tza2012",   "eth2012",   "eth2010",   "gha-glss6", "gha-glss5"), 
  labels=c("tza-nps-2012",   "eth-ess-2013",   "eth-erss-2011",   "gha-glss6", "gha-glss5"))]
g2 <- SpatialPolygonsDataFrame(g2, data.frame(g2.dt), match.ID="rn")

# TODO BMGF/SDI ag. potential quadrants


# Required RIGA components
vars.chr <- c("totcropprod", "totcropsold", "totagprod", "totagsold", "totlvstprod",
"totlivsold", "agowncons", "agmisc", "shagprodsold", "shagowncons",
"shagmisc", "shcropsold", "shlvstsold")

vars.inc <- c("farmrntimp", "agr_wge", "selfimp1", "transfersgrossimp", "otherincimp", 
  "nonfarmrntimp", "nonagr_wge", "selfemp",
  "cropincome1grossimp", "cropincome2grossimp", "livestockgrossimp") 

```


```{r gha, eval=FALSE}

# Load GHA GLSS constructed survey variables
load("~/Projects/2017-agra-aasr/tmp/2017-agra-aasr_GHA_cluster.RData")
rm(list=ls()[ls() %like% "mod."])
rm(X)

# Which vars are missing?
tmp <- lbl[!varCode %in% names(gha)]
setnames(gha, 
  c("croparea_clas", "naggross_clas", "cropsales_clas", "seg_quad"), 
  c("croparea_3clas", "naggross_3clas", "cropsales_3clas", "seg_quad_4"))

# Other fixes
gha[, `:=`(clust_pam3 = NULL, clust_pam5 = NULL, clust_pam5_2var = NULL)]
setnames(gha, "district", "district_cd")

```

```{r tza, eval=FALSE}

# Generate raw codebook
tmp <- list.files(c(
  "~/Data/TZA-NPS-14/raw", "~/Data/TZA-NPS-12/raw", 
  "~/Data/TZA-NPS-10/raw", "~/Data/TZA-NPS-08/raw"), 
  glob2rx("*.dta"), recursive=T, full.names=T)
tmp <- lapply(seq_along(tmp), function(x) {
  y <- read.dta13(tmp[x])
  y <- data.table(
    varCode=names(y), 
    varLabel=attr(y, "var.labels"), 
    svyCode=unlist(strsplit(tmp[x], "/"))[5],
    fName=unlist(strsplit(tmp[x], "/"))[7])
})
tmp <- rbindlist(tmp)
fwrite(tmp, "./data/tza_raw_codebook.csv")
tza.raw.lbl <- tmp

# Combine TZA 3 waves from RIGA-H
tza.f.adm <- c(
  "~/Data/TZA-NPS-12/riga/Tanzania13_HH_ADMIN_V12.dta",
  "~/Data/TZA-NPS-10/riga/Tanzania11_HH_ADMIN_V12.dta",
  "~/Data/TZA-NPS-08/riga/Tanzania09_HH_ADMIN.dta")
tza.f.chr <- c(
  "~/Data/TZA-NPS-12/riga/Tanzania13_HHCHAR_V12.dta",
  "~/Data/TZA-NPS-10/riga/Tanzania11_HHCHAR_V12.dta",
  "~/Data/TZA-NPS-08/riga/Tanzania09_HHCHAR.dta")
tza.f.inc <- c(
  "~/Data/TZA-NPS-12/riga/Tanzania13_HH_INCOME_V12.dta",
  "~/Data/TZA-NPS-10/riga/Tanzania11_HH_INCOME_V12.dta",
  "~/Data/TZA-NPS-08/riga/Tanzania09_HH_INCOME.dta")
tza.f.hh <- c(
  "~/Data/TZA-NPS-12/raw/HH_SEC_A.dta",
  "~/Data/TZA-NPS-10/raw/HH_SEC_A.dta",
  "~/Data/TZA-NPS-08/raw/SEC_A_T.dta")

###############################################
# ADMIN
tza.adm <- lapply(tza.f.adm, function(x) data.table(read.dta13(x)))

# Harmonize var codes
tmp <- unlist(lapply(tza.adm, names))
table(tmp)
# There are `locality` and `weight_trimmed` vars in tza09, but can be ignored
tza.adm[[3]][, `:=`(locality=NULL, weight_trimmed=NULL)]
# Add survey codes
tza.adm[[1]][, `:=`(svyCode="tza-nps-2012", wave="wave 3")]
tza.adm[[2]][, `:=`(svyCode="tza-nps-2010", wave="wave 2")]
tza.adm[[3]][, `:=`(svyCode="tza-nps-2008", wave="wave 1")]
# Wave 2 has codes for region instead of labels
setnames(tza.adm[[2]], "region", "region_cd")
# Check unique IDs
tza.adm[[3]][, .(range(hh), range(hhid))]
#                V1             V2
# 1: 01010140020171 01010140020171
# 2: 55020180210078 55020180210078
tza.adm[[2]][, .(range(hh), range(hhid))]
#                  V1               V2
# 1: 0101014002017101 0101014002017101
# 2: 5502018021007801 5502018021007801
tza.adm[[1]][, .(range(hh), range(hhid))]
#          V1       V2
# 1: 0001-001 0001-001
# 2: 3924-001 3924-001

# Combine all waves
tza.adm <- rbindlist(tza.adm, fill=TRUE)

# Add admin codes and labels
# Recodes
setnames(tza.adm, c("hhid", "hh", "ea"), c("hh", "hhid", "clust"))
tza.adm[, unique(urban), by=wave]
#     wave    V1
# 1: tza09 Rural
# 2: tza09 Urban
# 3: tza11 Rural
# 4: tza11 Urban
# 5: tza13 Rural
# 6: tza13 Urban
tza.adm[, rural := factor(urban, levels=c("Rural", "Urban"), labels=c("rural", "urban"))]
tza.adm[, urban := NULL]
tza.adm[, unique(region), by=wave]
# => wave 2 has codes for region instead of labels
tza.adm[, unique(district), by=.(wave, region)]
View(tza.adm[, unique(district), by=.(wave, region_cd)])
tza.adm[, .N, by=wave]
#     wave    N
# 1: tza13 4995
# 2: tza11 3913
# 3: tza09 3255
# tza09 regions are coded 1-5 (should be 8)?
# tza districts are coded 1-8, will need to merge district details from another source

# Merge admin vars into `tza`
# tza <- tza.adm
setnames(tza.adm, "district")
tza <- tza[, .SD, .SDcols=c("hhid", setdiff(names(tza), names(tza.adm)))]
setkey(tza, hhid)
setkey(tza.adm, hhid)
tza <- tza[tza.adm]

#############################################
# Fix tza13 admin codes
unique(tza, by="hhid")
tza[, `:=`(
  region=as.character(region),
  district=as.character(district)
  )]

tza[, `:=`(svyL1Nm=NULL, svyL2Nm=NULL, svyL1Cd=NULL, svyL2Cd=NULL)]

x <- c(
  "~/Data/TZA-NPS-12/raw/HH_SEC_A.dta",
  "~/Data/TZA-NPS-10/raw/HH_SEC_A.dta",
  "~/Data/TZA-NPS-08/raw/SEC_A_T.dta"
)

tmp <- read.dta13(x[1], convert.factors=F)
tmp <- data.table(tmp)
tmp[, range(y3_hhid)]
# [1] "0001-001" "3924-001"
tza[!hhid %in% tmp$y3_hhid, .N, by=wave]
setkey(tmp, y3_hhid)
setkey(tza, hhid)
tza[tmp, `:=`(
  svyL1Nm = as.character(i.hh_a01_2),
  svyL1Cd = as.integer(i.hh_a01_1),
  svyL2Nm = as.character(i.hh_a02_2),
  svyL2Cd = as.integer(i.hh_a02_1)
  )]
tmp <- read.dta13(x[1])
tmp <- attr(tmp, "label.table")$hh_a01_1
tmp <- data.table(svyCode="tza-nps-2012", svyL1Cd=tmp, svyL1Nm=names(tmp))
setkey(tmp, svyCode, svyL1Nm)
setkey(tza, svyCode, svyL1Nm)
tza[tmp,  svyL1Cd := i.svyL1Cd]

# Fix tza11 admin codes
tmp <- read.dta13(x[2])
tmp <- data.table(tmp)
tmp[, range(y2_hhid)]
tza[!hhid %in% tmp$y2_hhid, .N, by=wave]
setkey(tmp, y2_hhid)
setkey(tza, hhid)
tza[tmp, `:=`(
  svyL1Cd = i.region,
  svyL2Cd = i.district
  )]

# Fix tza09 admin codes
tmp <- read.dta13(x[3])
tmp <- data.table(tmp)
tmp[, range(hhid)]
tza[!hhid %in% tmp$hhid, .N, by=wave]
setkey(tmp, hhid)
setkey(tza, hhid)
tza[tmp, `:=`(
  svyL1Nm = as.character(i.region),
  svyL2Cd = as.integer(i.district)
  )]
tmp <- read.dta13(x[3])
tmp <- attr(tmp, "label.table")$REGION
tmp <- data.table(svyCode="tza-nps-2008", svyL1Cd=tmp, svyL1Nm=names(tmp))
setkey(tmp, svyCode, svyL1Nm)
setkey(tza, svyCode, svyL1Nm)
tza[tmp,  svyL1Cd := i.svyL1Cd]

tmp[, svyCode := "tza-nps-2010"]
setkey(tmp, svyCode, svyL1Cd)
setkey(tza, svyCode, svyL1Cd)
tza[tmp,  svyL1Nm := i.svyL1Nm]

# Verify
setnames(tza, c("district", "ward"), c("district_cd", "ward_cd"))
tza[, sum(is.na(svyL1Nm))/.N, by=wave]
tza[, sum(is.na(svyL1Cd))/.N, by=wave]
tza[, sum(is.na(svyL2Nm))/.N, by=wave]
tza[, sum(is.na(svyL2Cd))/.N, by=wave]
tmp <- tza[, .N, keyby=.(svyCode, svyL1Cd, svyL1Nm, svyL2Cd, svyL2Nm)]
# TODO still missing ward and district labels for tza09 and tza11



# Could also use hhld XY coords if I can find them (IFPRI?), in files:
x <- c(
  "~/Data/TZA-NPS-12/raw/HouseholdGeovars_Y3.dta",
  "~/Data/TZA-NPS-10/raw/HH.Geovariables_Y2.dta",
  "~/Data/TZA-NPS-08/raw/HH.Geovariables_Y1.dta")
tmp <- read.dta13(x[1])
tmp <- data.table(tmp)
tza[!hhid %in% tmp$y3_hhid, .N, by=wave]
#     wave    N
# 1: tza09 3255
# 2: tza11 3913
# 3: tza13   22
setkey(tmp, y3_hhid)
setkey(tza, hhid)
tza[tmp, `:=`(
  lon_dd_mod = lon_dd_mod,
  lat_dd_mod = lat_dd_mod
)]
tmp <- read.dta13(x[2])
tmp <- data.table(tmp)
tza[!hhid %in% tmp$y2_hhid, .N, by=wave]
#     wave    N
# 1: tza13 4995
# 2: tza09 3255
# 3: tza11    7
setkey(tmp, y2_hhid)
setkey(tza, hhid)
tza[tmp, `:=`(
  lon_dd_mod = lon_modified,
  lat_dd_mod = lat_modified
)]
tmp <- read.dta13(x[3])
tmp <- data.table(tmp)
tza[!hhid %in% tmp$hhid, .N, by=wave]
#     wave    N
# 1: tza13 4995
# 2: tza11 3913
# 3: tza09  459
setkey(tmp, hhid)
setkey(tza, hhid)
tza[tmp, `:=`(
  lon_dd_mod = lon_modified,
  lat_dd_mod = lat_modified
)]
tza[, sum(is.na(lon_dd_mod)), by=wave]
#     wave  V1
# 1: tza13  22
# 2: tza09 459
# 3: tza11   7

###############################################
# HHCHAR
tza.chr <- lapply(tza.f.chr, function(x) data.table(read.dta13(x)))

# Harmonize var codes
tmp <- unlist(lapply(tza.chr, names))
tmp <- table(tmp)
vars.chr[!vars.chr %in% names(tmp)]
vars.chr <- names(tmp)[tmp==3]
tza.chr <- lapply(tza.chr, function(x) x[, .SD, .SDcols=vars.chr])
tza.chr <- rbindlist(tza.chr)
unique(tza.chr, on="hh")
tza[!hhid %in% tza.chr$hh, .(svyCode, hhid)]
# Empty data.table (0 rows) of 2 cols: svyCode,hhid
setkey(tza.chr, hh)
setkey(tza, hhid)
tza <- tza.chr[tza]
setnames(tza, c("hh", "i.hh"), c("hhid", "hh"))
tza[, i.district := NULL]

###############################################
# INCOME
tza.inc <- lapply(tza.f.inc, function(x) data.table(read.dta13(x)))

# Harmonize var codes
tmp <- unlist(lapply(tza.inc, names))
tmp <- table(tmp)
vars.inc[!vars.inc %in% names(tmp)]
tza.inc <- lapply(tza.inc, function(x) x[, .SD, .SDcols=c("hh", vars.inc)])
tza.inc <- rbindlist(tza.inc)
unique(tza.inc, on="hh")
tza[!hhid %in% tza.inc$hh, .(svyCode, hhid)]
# Empty data.table (0 rows) of 2 cols: svyCode,hhid
setkey(tza.inc, hh)
setkey(tza, hhid)
tza <- tza.inc[tza]

# Extra recodes
setnames(tza, c("hh", "i.hh"), c("hhid", "hh"))
tza[, landrent := rowSums(cbind(landrent, landlend), na.rm=T)]
tza[, `:=`(hh=NULL, distmarket_ag=NULL, distroad_ag=NULL, disthome_ag=NULL, landlend=NULL)]
setnames(tza, "ea", "clust")
tza[, svyCode := factor(svyCode, levels=c("tza-nps-2012", "tza-nps-2010", "tza-nps-2008"))]
tza[, survey := factor(svyCode, levels=levels(svyCode), labels=c("2012/13", "2010/11", "2008/09"))]
tza[, wave := factor(svyCode, levels=levels(svyCode), labels=c("wave 3", "wave 2", "wave 1"))]

##############################################
# STRATIFICATION
# Add stratification vars (7 zones, 6 ez?), these are not available from the RIGA files
# Note that wards are marked as CONFIDENTIAL
tza.hh <- lapply(tza.f.hh, function(x) data.table(read.dta13(x)))
tza.hh[[1]][, wave := "wave 3"]
tza.hh[[2]][, wave := "wave 2"]
tza.hh[[3]][, wave := "wave 1"]
tza[, range(hhid), by=wave]
#      wave               V1
# 1: wave 3         0001-001
# 2: wave 3         3924-001
# 3: wave 1   01010140020171
# 4: wave 1   55020180210078
# 5: wave 2 0101014002017101
# 6: wave 2 5502018021007801

setkey(tza.hh[[1]], wave, y3_hhid)
setkey(tza.hh[[2]], wave, y2_hhid)
setkey(tza.hh[[3]], wave, hhid)
setkey(tza, wave, hhid)
tza[, `:=`(clust=NULL, strata=NULL, weight=NULL, ward=NULL)]
tza[tza.hh[[1]], `:=`(clust=i.clusterid, strata=i.strataid, ward=i.hh_a03_1, weight=i.y3_weight,
  svyL3Cd=i.hh_a03_1, svyL3Nm=i.hh_a03_2)]
tza[tza.hh[[2]], `:=`(clust=i.clusterid, strata=i.strataid, ward=i.ward, weight=i.y2_weight)]
tza[tza.hh[[3]], `:=`(clust=i.clusterid, strata=i.strataid, ward=i.ward, weight=i.hh_weight)]
tza[svyL3Nm=="", svyL3Nm := NA]

# urban/rural breakdown is weird for wave 3 (was `mixed` recoded `urban`)?

# Verify
tza[, range(clust), by=wave]
#      wave       V1
# 1: wave 3  1114002
# 2: wave 3 55218021
# 3: wave 2  1114002
# 4: wave 2 55218021
# 5: wave 1  1114002
# 6: wave 1 55218021

tza[, range(strata), by=wave]
#      wave V1
# 1: wave 3  1
# 2: wave 3 16
# 3: wave 2  1
# 4: wave 2 16
# 5: wave 1  1
# 6: wave 1 16

tza[, range(weight), by=wave]
#      wave          V1
# 1: wave 3    24.82792
# 2: wave 3 13538.68262
# 3: wave 2    74.96050
# 4: wave 2 10446.71191
# 5: wave 1   212.82059
# 6: wave 1  5688.66260

# Map household by strata to verify
tmp <- tza[, .N, keyby=.(wave, strata)]
tza.pts <- SpatialPointsDataFrame(tza[!is.na(lon_dd_mod), .(lon_dd_mod, lat_dd_mod)], 
  data.frame(tza[!is.na(lon_dd_mod), .(survey, wave, svyCode, hhid, strata, svyL1Nm, svyL2Nm, svyL3Nm)]),
  proj4string=CRS("+init=epsg:4326"))


###############################################
# TODO FARM MANAGEMENT
# Include IFPRI recodes (last wave only for each country unfortunately)
ifpri[, .N, by=svyCode]
#   svyCode     N
# 1: eth2010 27835
# 2: nga2012  4536
# 3: tza2012  4878
# 4: gha2012 16772


###############################################
# QUADRANTS
# Received hhld classification across CELL5M and agpot from World Bank on 2017.10.16
wb <- lapply(list.files("./out/WB", full.names=TRUE), fread, integer64="character")
wb <- lapply(seq_along(wb), function(x) {
  wb[[x]][, source := basename(list.files("./out/WB")[x])]
  setnames(wb[[x]], 1, "hhid")
  })
wb <- rbindlist(wb)
wb[, .N, by=source]
#             source    N
# 1: ETH_ERSS_Y1.csv 3969
# 2:  ETH_ESS_Y2.csv 5290
# 3:  ETH_ESS_Y3.csv 4954
# 4:  TZA_NPS_Y1.csv 3265
# 5:  TZA_NPS_Y2.csv 3924
# 6:  TZA_NPS_Y3.csv 4988

tza[, .N, by=svyCode]
#         svyCode    N
# 1: tza-nps-2012 4995
# 2: tza-nps-2010 3913
# 3: tza-nps-2008 3255

wb[, svyCode := factor(source)]
levels(wb$svyCode)
# [1] "ETH_ERSS_Y1.csv" "ETH_ESS_Y2.csv"  "ETH_ESS_Y3.csv"  "TZA_NPS_Y1.csv"  "TZA_NPS_Y2.csv"  "TZA_NPS_Y3.csv"
levels(wb$svyCode) <- c("eth-erss-2011", "eth-ess-2013", "eth-ess-2015", 
  "tza-nps-2008", "tza-nps-2010", "tza-nps-2012")

# Merge raster values into `tza`
setkey(tza, svyCode, hhid)
setkey(wb, svyCode, hhid)
tza[wb, `:=`(
  cell5m = hc_seq_5m,
  suit_gaez = res03_crav6190l_silr_cer
  )]

# Verify
tza[, .N, by=.(svyCode, is.na(cell5m))]
#         svyCode is.na    N
# 1: tza-nps-2012 FALSE 4973
# 2: tza-nps-2012  TRUE   22
# 3: tza-nps-2010 FALSE 3913
# 4: tza-nps-2008 FALSE 3255

tza[, .N, by=.(svyCode, is.na(suit_gaez))]
#         svyCode is.na    N
# 1: tza-nps-2012 FALSE 4586
# 2: tza-nps-2012  TRUE  409
# 3: tza-nps-2010 FALSE 3584
# 4: tza-nps-2010  TRUE  329
# 5: tza-nps-2008 FALSE 2969
# 6: tza-nps-2008  TRUE  286

# Merge in HarvestChoice travel times `tt20k_mean`
# Load CELL5M
load("~/Projects/hc-cell5m/rdb/2016.03/cell5m.rda")
dt <- dt[, .SD, .SDcols=c("CELL5M", names(dt)[names(dt) %like% "tt10_"])]
setnames(dt, 2:6, c("tt20k_mean", "tt50k_mean", "tt100k_mean", "tt250k_mean", "tt500k_mean"))
setkey(dt, CELL5M)
setkey(tza, cell5m)
tza <- dt[tza]
rm(dt)
summary(tza$tt100k_mean)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 0.2026  1.7276  3.8615  5.4971  7.6794 51.7875     644
# => why 644 NAs, since no NA in `wb`, and only 22 hhlds didn't merge?
setnames(tza, "CELL5M", "cell5m")
summary(tza$cell5m)

# Classify GAEZ suitability into `seg_suit_gaez` (agpot-hi, agpot-lo, agpot-no)
# GAEZ suitability is coded from 1 to 9:
# 0-no data, 1-very high (> 85%), 2-high (> 70%), 3-good (> 55%), 4-medium (> 40%), 
# 5-moderate (> 25%), 6-marginal (> 10%), 7-very marginal (> 0%), 8-not suitable (0%), 9-water
tza[suit_gaez %between% c(1,4), seg_suit_gaez := "agpot-hi"]
tza[suit_gaez %between% c(5,7), seg_suit_gaez := "agpot-lo"]
tza[suit_gaez %between% c(8,9), seg_suit_gaez := "agpot-no"]
tza[, seg_suit_gaez := factor(seg_suit_gaez, levels=c("agpot-hi", "agpot-lo", "agpot-no"))]
tza[, .N, keyby=.(svyCode, seg_suit_gaez)]
# Note there is no suit_gaez==0 but there are missing values 

# Encode `suit_gaez` labels
tza[, suit_gaez := factor(suit_gaez, levels=0:9, 
  labels=c(
    "0-no data", "1-very high (> 85%)", "2-high (> 70%)", 
    "3-good (> 55%)", "4-medium (> 40%)", "5-moderate (> 25%)", 
    "6-marginal (> 10%)", "7-very marginal (> 0%)", "8-not suitable (0%)", "9-water"))]


# Classify market access into `seg_mkt20k` (mkt-lo, mkt-hi) using 4hr cutoff 
tza[, `:=`(
  seg_mkt20k = factor(tt20k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt50k = factor(tt50k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt100k = factor(tt100k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt250k = factor(tt250k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt500k = factor(tt500k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi"))
)]
tza[, .N, keyby=.(svyCode, seg_mkt100k)]

# Make quadrants `seg_quad` using 100K market size
# (agpot-lo / mkt-lo, agpot-lo / mkt-hi, agpot-hi / mkt-lo, agpot-hi / mkt-hi)
tza[, seg_quad := factor(paste(seg_suit_gaez, seg_mkt100k, sep=" / "))]
# Arbitrarily classify seg_mkt100k==NA into "mkt-lo"
# Arbitrarily classify seg_suit_gaez==NA and seg_suit_gaez="agpot-no" into "agpot-lo"
levels(tza$seg_quad)
#  [1] "agpot-hi / mkt-hi" "agpot-hi / mkt-lo" "agpot-hi / NA"     "agpot-lo / mkt-hi" "agpot-lo / mkt-lo"
#  [6] "agpot-lo / NA"     "agpot-no / mkt-hi" "agpot-no / mkt-lo" "NA / mkt-hi"       "NA / mkt-lo"      
# [11] "NA / NA"  
levels(tza$seg_quad) <- c(
  "agpot-hi / mkt-hi", "agpot-hi / mkt-lo", "agpot-hi / mkt-lo", "agpot-lo / mkt-hi", 
  "agpot-lo / mkt-lo", "agpot-lo / mkt-lo", "agpot-lo / mkt-hi", "agpot-lo / mkt-lo", 
  "agpot-lo / mkt-hi", "agpot-lo / mkt-lo", "agpot-lo / mkt-lo")
# Reorder levels
tza[, seg_quad := factor(seg_quad, levels=quad)]
table(tza$seg_quad)
# agpot-lo / mkt-lo agpot-lo / mkt-hi agpot-hi / mkt-lo agpot-hi / mkt-hi 
#              3131              1836              3227              3969

# Verify visually
tmap_mode("view")
tmp <- tza[svyCode=="tza-nps-2012" & !is.na(lon_dd_mod)]
tmp <- SpatialPointsDataFrame(tmp[, .(lon_dd_mod, lat_dd_mod)], 
  data.frame(tmp[, .SD, .SDcols=c("seg_quad")]), proj4string=CRS("+init=epsg:4326"))
tm_shape(rquad) + tm_raster(pal=viridis(4), breaks=0:4, labels=quad, alpha=.6) +
  tm_shape(tmp, is.master=T) + tm_dots("seg_quad", pal=viridis(4))
# => looks OK


###############################################
# RURAL/URBAN splits
# Verify all definitions across panels. The split in 2012 seems problematic.
# Ignore RIGA, pull in data from raw tables instead.
# In 2008, 2 vars `hhid`, `rural` and `locailty`
# In 2010, 2 vars `y2_hhid`, `y2_rural` and `hh_a14`
# In 2012, 2 vars `y3_hhid`, `y3_rural`, and `hh_a11`
tza.f.rur <- c(
  "~/Data/TZA-NPS-12/raw/HH_SEC_A.dta", 
  "~/Data/TZA-NPS-10/raw/HH_SEC_A.dta",
  "~/Data/TZA-NPS-08/raw/SEC_A_T.dta"
  )
tza.rur <- lapply(tza.f.rur, function(x) data.table(read.dta(x)))
tza.rur[[1]] <- tza.rur[[1]][, .SD, .SDcols=c("y3_hhid", "y3_rural", "hh_a11")]
tza.rur[[2]] <- tza.rur[[2]][, .SD, .SDcols=c("y2_hhid", "y2_rural", "hh_a14")]
tza.rur[[3]] <- tza.rur[[3]][, .SD, .SDcols=c("hhid", "rural", "locality")]
tza.rur <- lapply(tza.rur, setnames, c("hhid", "rural", "locality"))
tza.rur[[1]][, svyCode := "tza-nps-2012"]
tza.rur[[2]][, svyCode := "tza-nps-2010"]
tza.rur[[3]][, svyCode := "tza-nps-2008"]
tza.rur <- rbindlist(tza.rur)
tza.rur[, .N, keyby=.(svyCode, rural)]
#         svyCode rural    N
# 1: tza-nps-2008 Rural 2063
# 2: tza-nps-2008 Urban 1202
# 3: tza-nps-2010 urban 1295
# 4: tza-nps-2010 rural 2629
# 5: tza-nps-2012 URBAN 1791
# 6: tza-nps-2012 RURAL 3219

tza[, .N, keyby=.(svyCode, rural)]
#         svyCode rural    N
# 1: tza-nps-2012 rural 4227
# 2: tza-nps-2012 urban  768
# 3: tza-nps-2010 rural 2519
# 4: tza-nps-2010 urban 1394
# 5: tza-nps-2008 rural 2055
# 6: tza-nps-2008 urban 1200

tza.rur[, .N, keyby=.(svyCode, rural, locality)]
#          svyCode rural          locality    N
#  1: tza-nps-2008 Rural             Rural 1591
#  2: tza-nps-2008 Rural           Mixture  472
#  3: tza-nps-2008 Urban             Urban  794
#  4: tza-nps-2008 Urban           Mixture  408
#  5: tza-nps-2010 urban               YES 1295
#  6: tza-nps-2010 rural                NA    1
#  7: tza-nps-2010 rural               YES 2628
#  8: tza-nps-2012 URBAN  IN SAME LOCATION  985
#  9: tza-nps-2012 URBAN    LOCAL TRACKING  464
# 10: tza-nps-2012 URBAN DISTANCE TRACKING  342
# 11: tza-nps-2012 RURAL  IN SAME LOCATION 2148
# 12: tza-nps-2012 RURAL    LOCAL TRACKING  663
# 13: tza-nps-2012 RURAL DISTANCE TRACKING  408

# => merge in `rural` into `tza`
setkey(tza, svyCode, hhid)
setkey(tza.rur, svyCode, hhid)
tza[tza.rur, rural := i.rural]

# Recode
tza[, .N, keyby=.(svyCode, rural)]
tza[, rural := factor(rural)]
levels(tza$rural) <- c("rural", "urban", "rural", "urban", "rural", "urban")
tza[, .N, keyby=.(svyCode, rural)]
#         svyCode rural    N
# 1: tza-nps-2012 rural 3209
# 2: tza-nps-2012 urban 1786
# 3: tza-nps-2010 rural 2622
# 4: tza-nps-2010 urban 1291
# 5: tza-nps-2008 rural 2055
# 6: tza-nps-2008 urban 1200


###############################################
# PANEL/POPULATION WEIGHTS, `phhid`, `pweight`, `pcount`
# Bring in household concordance across panels from `NPSY3.PANEL.KEY.dta`
tza.panel <- data.table(read.dta("~/Data/TZA-NPS-12/raw/NPSY3.PANEL.KEY.dta"))
tza[, `:=`(y1_hhid=NULL, y2_hhid=NULL, y3_hhid=NULL, phhid=NULL, pweight=NULL, pcount=NULL)]
# Remove empty strings
tza.panel[, `:=`(
  y1_hhid = ifelse(y1_hhid=="", NA, y1_hhid),
  y2_hhid = ifelse(y2_hhid=="", NA, y2_hhid),
  y3_hhid = ifelse(y3_hhid=="", NA, y3_hhid)
)]
setkey(tza, hhid)

setkey(tza.panel, y1_hhid)
tza[tza.panel, `:=`(y1_hhid = hhid, y2_hhid = i.y2_hhid, y3_hhid = i.y3_hhid, 
  phhid = i.UPI3)]

setkey(tza.panel, y2_hhid)
tza[tza.panel, `:=`(y1_hhid = i.y1_hhid, y2_hhid = hhid, y3_hhid = i.y3_hhid, 
  phhid = i.UPI3)]

setkey(tza.panel, y3_hhid)
tza[tza.panel, `:=`(y1_hhid = i.y1_hhid, y2_hhid = i.y2_hhid, y3_hhid = hhid, 
  phhid = i.UPI3)]

# Bring in adjusted panel weights from `Y3_weights.dta`
tmp <- data.table(read.dta("~/Data/TZA-NPS-12/raw/Y3_weights.dta"))
setkey(tmp, y3_hhid)
setkey(tza, y3_hhid)
tza[tmp, pweight := i.y3_panelweight]

# Verify
tza[, pcount := .N, by=phhid]
dcast(tza, svyCode~pcount)
        svyCode    1    2    3
1: tza-nps-2012 1486  926 2583
2: tza-nps-2010  127 1203 2583
3: tza-nps-2008  329  343 2583


###############################################
# COMPARISONS WITH EPAR
# Need to re-estimate proportions for farms <= 4 ha across waves
# Load EPAR hhld proportions across categories (these are obviously unweighted)
# I only have the 3x3 classification counts
epar <- fread("~/Projects/2017-agra-aasr/out/EPAR/EPAR_UW_356_Categorizing Smallholder Farmers in ETH and TZ_5.17.17_SRW.csv")
setnames(epar, c("country", "wave", "rural", "croparea_clas", "cropsales_3clas", "naggross_3clas", "N"))
tmp <- epar[croparea_clas!="0 < ha <= 4" & rural=="Both", 
  .(N=sum(N, na.rm=T)), by=.(country, wave, cropsales_3clas, naggross_3clas, croparea_clas)]
tmp[, total := sum(N), by=.(country, wave)]
tmp[, pct := 100*N/total]
tmp[, sum(pct), by=.(country, wave)]
tmp <- dcast(tmp, country+wave+naggross_3clas~croparea_clas+cropsales_3clas, value.var="pct")
fwrite(tmp, "./out/EPAR/EPAR_UW_356_Categorizing Smallholder Farmers in ETH and TZ.csv")


```

```{r eth, eval=FALSE}

# Generate raw codebook
tmp <- list.files(c(
  "~/Data/ETH-ERSS-11/raw", "~/Data/ETH-ESS-13/raw", "~/Data/ETH-ESS-15/raw"), 
  glob2rx("*.dta"), recursive=T, full.names=T)
tmp <- lapply(seq_along(tmp), function(x) {
  y <- read.dta13(tmp[x])
  y <- data.table(
    varCode=names(y), 
    varLabel=attr(y, "var.labels"), 
    svyCode=unlist(strsplit(tmp[x], "/"))[5],
    fName=str_replace(tmp[x], "/home/mbacou/Data/", ""))
})
tmp <- rbindlist(tmp)
fwrite(tmp, "./data/eth_raw_codebook.csv")
eth.raw.lbl <- tmp

# Combine ETH 3 waves from RIGA-H
# Note that RIGA 2015 is not available yet
eth.f.adm <- c(
  "~/Data/ETH-ESS-15/riga/Ethiopia15_HH_ADMIN.dta",
  "~/Data/ETH-ESS-13/riga/Ethiopia13_HH_ADMIN.dta",
  "~/Data/ETH-ERSS-11/riga/Ethiopia12_HH_ADMIN.dta")
eth.f.chr <- c(
  "~/Data/ETH-ESS-15/riga/Ethiopia15_HHCHAR.dta",
  "~/Data/ETH-ESS-13/riga/Ethiopia13_HHCHAR.dta",
  "~/Data/ETH-ERSS-11/riga/Ethiopia12_HHCHAR.dta")
eth.f.inc <- c(
  "~/Data/ETH-ESS-15/riga/Ethiopia15_HH_INCOME.dta",
  "~/Data/ETH-ESS-13/riga/Ethiopia13_HH_INCOME.dta",
  "~/Data/ETH-ERSS-11/riga/Ethiopia12_HH_INCOME.dta")
eth.f.hh <- c(
  "~/Data/ETH-ESS-15/raw/Geovariables/ETH_HouseholdGeovars_y3.dta",
  "~/Data/ETH-ESS-13/raw/Pub_ETH_HouseholdGeovars_Y2.dta",
  "~/Data/ETH-ERSS-11/raw/Pub_ETH_HouseholdGeovariables_Y1.dta")
eth.f.xtra <- c(
  "~/Data/ETH-ESS-15/raw/Household/sect_cover_hh_w3.dta",
  "~/Data/ETH-ESS-13/raw/sect_cover_hh_w2.dta",
  "~/Data/ETH-ERSS-11/raw/HH/sect_cover_hh_w1.dta")


###############################################
# ADMIN
eth.adm <- lapply(eth.f.adm[-1], function(x) data.table(read.dta13(x, generate.factors=T)))

# Harmonize var codes
tmp <- unlist(lapply(eth.adm, names))
table(tmp)

# Diff between `hh` and `household_id2`?
eth.adm[[1]][, .N, by=is.na(hh)]
eth.adm[[2]][, .N, by=is.na(hhid)]
eth.adm[[1]][, sum(hh != household_id2), by=region]
eth.adm[[2]][, sum(hhid != household_id), by=region]
eth.adm[[1]][, range(woreda)]
eth.adm[[2]][, range(woreda)]
# => all equal
eth.adm[[1]][, household_id2 := NULL]
eth.adm[[2]][, household_id := NULL]
setnames(eth.adm[[1]], "hh", "hhid")

eth.adm[[1]][, svyCode := "eth-ess-2013"]
eth.adm[[2]][, svyCode := "eth-erss-2011"]
eth.adm[[1]][, wave := "wave 2"]
eth.adm[[2]][, wave := "wave 1"]

eth.adm[[1]][, range(hhid)]
# [1] "010101088801601002" "150102088803102121"
eth.adm[[2]][, range(hhid)]
# [1] "01010101601002" "15010203102121"

# Combine all waves
eth.adm <- rbindlist(eth.adm)

# Recodes
setnames(eth.adm, "ea_id", "clust")
setnames(eth.adm, "woreda", "district")
setnames(eth.adm, "urban", "rural")
levels(eth.adm$rural) <- c("rural", "urban", "rural")

# Verify admin codes and labels
eth.adm[, .N, keyby=.(svyCode, region, rural)]
eth.adm[, .N, keyby=.(svyCode, region, district)]
# => woredas are coded, we need labels
levels(eth.adm$region)

eth.adm[svyCode=="eth-ess-2013", range(district)]
eth.adm[svyCode=="eth-erss-2011", range(district)]

# Verify `clust`
eth.adm[, .N, by=.(svyCode, region, clust=="")]
# => it's messed up, lots of empty strings, bring in raw data later

# Merge all admin vars
# eth <- eth.adm
eth <- eth[, .SD, .SDcols=c("hhid", setdiff(names(eth), names(eth.adm)))]
setkey(eth, hhid)
setkey(eth.adm, hhid)
eth <- eth[eth.adm]

###############################################
# HHCHAR
eth.chr <- lapply(eth.f.chr[-1], function(x) data.table(read.dta13(x, generate.factors=T)))

# Harmonize var codes
tmp <- unlist(lapply(eth.chr, names))
tmp <- table(tmp)
# Only `cellphone` var is missing from 2011
eth.chr[[2]][, cellphone := NA]
vars.chr[!vars.chr %in% names(tmp)]
tmp <- unlist(lapply(eth.chr, names))
tmp <- table(tmp)
vars.chr <- names(tmp)[tmp==2]
eth.chr <- lapply(eth.chr, function(x) x[, .SD, .SDcols=vars.chr])
eth.chr <- rbindlist(eth.chr)

setnames(eth.chr, "hh", "hhid")
anyDuplicated(eth.chr, by="hhid")
# => OK
anyDuplicated(eth, by="hhid")
# => OK
eth[!hhid %in% eth.chr$hhid, .(svyCode, hhid)]
# Empty data.table (0 rows) of 2 cols: svyCode,hhid

# Merge into `eth`
eth <- eth[, .SD, .SDcols=c("hhid", setdiff(names(eth), names(eth.chr)))]
setkey(eth.chr, hhid)
setkey(eth, hhid)
eth <- eth.chr[eth]

# Recode TLU
eth[, TLU_sheep := rowSums(cbind(TLU_sheep, TLU_goats), na.rm=T)]
eth[, TLU_small := rowSums(cbind(TLU_chicken, TLU_otheranim), na.rm=T)]
eth[, `:=`(TLU_goats=NULL, TLU_chicken=NULL, TLU_otheranim=NULL)]
setnames(eth, "TLU_donkeyhorses", "TLU_horse")

###############################################
# INCOME
eth.inc <- lapply(eth.f.inc[-1], function(x) data.table(read.dta13(x, generate.factors=T)))

# Harmonize var codes
tmp <- unlist(lapply(eth.inc, names))
tmp <- table(tmp)
names(tmp)[tmp==1]
# [1] "socialtransfer"    "socialtransferimp"
vars.inc <- lbl[section=="income" & source=="RIGA", varCode]
vars.inc <- vars.inc[-c(22:27)]
# => note that some inc variables from TZA and GHA seem missing or might be labelled
# differently, we need to locate them:
#  [1] "agmisc"       "agowncons"    "shagmisc"     "shagowncons"  "shagprodsold" "shcropsold"  
#  [7] "shlvstsold"   "totagprod"    "totagsold"    "totcropprod"  "totcropsold"  "totlivsold"  
# [13] "totlvstprod" 
vars.inc <- vars.inc[vars.inc %in% names(tmp)]

# share_agtot - Share of income from crop, livestock and agricultural wages (net)
# share_nonagtot - Share of income from non-ag wage, selfemp, transfers, other (net)
# share_onfarm - Share of income from crop, livestock activities (net)
# share_offarm - Share of income from ag-wage, non-ag wage, selfemp, transfers, other (net)
# share_nonfarm - Share of income from non-ag wage and selfemp (net)
# sh2crop2 - Share of crop production in totincome1

# Also add gross values
vars.inc <- c(vars.inc, "hhid",
  "cropincome1grossimp", "cropincome2grossimp", "livestockgrossimp",
  "share_agtot", "share_nonagtot", "share_onfarm", "share_offarm", "share_nonfarm", "sh2crop2")
eth.inc <- lapply(eth.inc, function(x) x[, .SD, .SDcols=vars.inc])
eth.inc <- rbindlist(eth.inc)

anyDuplicated(eth.inc, by="hhid")
eth[!hhid %in% eth.inc$hhid, .(svyCode, hhid)]
# 178 households with no income variables
setkey(eth.inc, hhid)
setkey(eth, hhid)
eth <- eth.inc[eth]

# Verify share units
eth[, summary(share_agtot)]
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# -2.0412  0.0155  0.8525  0.6124  1.0000  3.4568     320
# => obvisously net shares
eth[, summary(share_nonagtot)]
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# -2.4568  0.0000  0.1475  0.3876  0.9845  3.0412     320
# => obvisously net shares, we need to use gross values instead


##############################################
# TODO AGRICULTURAL SALES `cropsales_sh`, `agsales_sh`
# RIGA is missing all sales variables!
# Extract volume shares (not values) from the raw survey records
#
# In `ETH-ESS-13/raw/sect11_ph_w2.dta`
# crop_name	Crop Name
# crop_code	Crop Code
# ph_s11q03_a	How much of the harvest [Crop] was sold in total? (Kilo)
# ph_s11q10a_3	Kgs. of harvested [CROP] used for household consumption
# ph_s11q10_3	Kgs. of harvested [CROP] given for gifts as reimbursement for labor
# ph_s11q11_3	Kgs. of harvested [CROP] used as reimbursements for inputs borrowed
# ph_s11q12_3	Kgs. of harvested [CROP] used for animal feed
# ph_s11q14_3	Kgs. of harvested [CROP] saved for seed
# ph_s11q15_3	Kgs. of harvested [CROP] lost to rotting, insects, rodents, theft, etc.
# ph_s11q22_a	What proportion of your crop product have you used for HOUSEHOLD CONSUMPTION
# ph_s11q22_b	What proportion of your crop product have you used for IN-KIND WAGES, PAYMENTS
# ph_s11q22_c	What proportion of your crop product have you used for ANIMAL FEED
# ph_s11q22_d	What proportion of your crop product have you used for SEED
# ph_s11q22_e	What proportion of your crop product have you used for SALE
# ph_s11q22_f	What proportion of your crop product have you used for OTHERS
#
# in `ETH-ESS-13/raw/sect12_ph_w2.dta`
# crop_name	Crop Name
# crop_code	Tree/Fruit/Root Crop Code
# ph_s12q03	What was the total amount of [TREES/FRUIT/ROOT CROP] harvested in this harvest
# ph_s12q07	What was the total quantity sold? (KG)
#
# In `ETH-ERSS-11/raw/PH/sect11_ph_w1.dta`
# crop_name	Crop Name
# crop_code	Crop Code
# ph_s11q03_a	How much of the harvest [Crop] was sold in total? (Kilo)
# ph_s11q10_a	How much of the harvest [Crop] during [Current Agriculture Season] was given out
# ph_s11q11_a	How much of the harvest [Crop] was given out as reimbursements for inputs borrow
# ph_s11q12_a	How much of the harvest [Crop] was used for animal feed? (Kilo)
# ph_s11q13_a	How much of the harvested [Crop] was used as inputs for [Crop] by-products that 
# ph_s11q14_a	How much of the harvested [Crop] was saved for seed? (Kilo)
# ph_s11q15_a	How much of the harvested [Crop] was lost to rotting, insects, rodents, theft, e
# ph_s11q22_a	What proportion of your crop product have you used for [HH Consumption]?
# ph_s11q22_b	What proportion of your crop product have you used for [Seed]?
# ph_s11q22_c	What proportion of your crop product have you used for [Sale]?
# ph_s11q22_d	What proportion of your crop product have you used for [Kind]?
# ph_s11q22_e	What proportion of your crop product have you used for [Animal Feed]?
# ph_s11q22_f	What proportion of your crop product have you used for [Others]?
#
# In `ETH-ERSS-11/raw/PH/sect12_ph_w1.dta`
# crop_name	Crop Name
# crop_code	Tree/Fruit/Root Crop Code
# ph_s12q03	What was the total amount of [Fruit/Root Crop] harvested in the past 12 months?
# ph_s12q07	What was the total quantity sold? (KG)

eth.f.crop <- c(
  "~/Data/ETH-ESS-13/raw/sect11_ph_w2.dta",
  "~/Data/ETH-ESS-13/raw/sect12_ph_w2.dta",
  "~/Data/ETH-ERSS-11/raw/PH/sect11_ph_w1.dta",
  "~/Data/ETH-ERSS-11/raw/PH/sect12_ph_w1.dta")

x <- c("crop_code", "crop_name", "")

eth.crop <- lapply(eth.f.crop, read.dta13, generate.factors=T)
eth.crop <- lapply(eth.crop, data.table)
# Verify crop sales shares `ph_s11q22_c`
eth.crop[[1]][, summary(ph_s11q22_e)]
pplot(ph_s11q22_e~crop_name, data=eth.crop[[1]], ylim=c(0,100))
# => max to 500, but it's an outlier graph it
eth.crop[[3]][, summary(ph_s11q22_c)]
# => OK, max to 100
# Combine crop datasets along household/crop
eth.crop[[1]] <- eth.crop[[1]][, .SD, 
  .SDcols=c("household_id2", "crop_name", "crop_code", "ph_s11q22_e", "ph_s11q03_a")]
eth.crop[[2]] <- eth.crop[[2]][, .SD, 
  .SDcols=c("household_id2", "crop_name", "crop_code", "ph_s12q03", "ph_s12q07")]
eth.crop[[3]] <- eth.crop[[3]][, .SD, 
  .SDcols=c("household_id", "crop_name", "crop_code", "ph_s11q03_a", "ph_s11q22_c")]
eth.crop[[4]] <- eth.crop[[4]][, .SD, 
  .SDcols=c("household_id", "crop_name", "crop_code", "ph_s12q03", "ph_s12q07")]

setnames(eth.crop[[3]], "ph_s11q22_c", "ph_s11q22_e")
eth.crop <- lapply(eth.crop, setnames, 1, "hhid")
eth.crop[[1]][, svyCode := "eth-ess-2013"]
eth.crop[[2]][, svyCode := "eth-ess-2013"]
eth.crop[[3]][, svyCode := "eth-erss-2011"]
eth.crop[[4]][, svyCode := "eth-erss-2011"]
eth.crop <- rbindlist(eth.crop, fill=TRUE)
pplot(ph_s11q22_e~crop_name, data=eth.crop[[1]], ylim=c(0,100))

setnames(eth.crop, c(4:5,7:8), c("cropsold_sh", "cropsold_kg", "hortprod_kg", "hortsold_kg"))
eth.crop[, cropsold_sh_imp := ifelse(cropsold_sh > 100, 100, cropsold_sh)]
eth.crop[, cropprod_kg := cropsold_kg * 100 / cropsold_sh_imp]
eth.crop[, cropprod_kg := ifelse(cropprod_kg %in% c(Inf, NaN), NA, cropprod_kg)]
eth.crop[, totcropprod_kg := rowSums(cbind(cropprod_kg, hortprod_kg), na.rm=T)]
eth.crop[, totcropsold_kg := rowSums(cbind(cropsold_kg, hortsold_kg), na.rm=T)]
eth.crop[, totcropprod_kg := sum(totcropprod_kg, na.rm=T), by=.(svyCode, hhid)]
eth.crop[, totcropsold_kg := sum(totcropsold_kg, na.rm=T), by=.(svyCode, hhid)]
eth.crop[, summary(totcropprod_kg)]
eth.crop[, summary(totcropsold_kg)]
eth.crop[, cropsales_sh := totcropsold_kg/totcropprod_kg]
eth.crop[, cropsales_sh := ifelse(cropsales_sh %in% c(Inf, NaN), NA, cropsales_sh)]
eth.crop[, cropsales_sh := ifelse(cropsales_sh > 1, 1, cropsales_sh)]
eth.crop[, summary(cropsales_sh)]
eth.crop[is.na(cropsales_sh), uniqueN(hhid), by=svyCode]
#          svyCode  V1
# 1: eth-erss-2011 696
# 2:  eth-ess-2013 464

# Merge into `eth`
setkey(eth.crop, svyCode, hhid)
setkey(eth, svyCode, hhid)
eth[eth.crop, `:=`(
  totcropprod_kg = i.totcropprod_kg, 
  totcropsold_kg = i.totcropsold_kg, 
  cropsales_sh = i.cropsales_sh
  )]
eth[is.na(cropsales_sh), uniqueN(hhid), by=.(svyCode, rural)]
#          svyCode rural   V1
# 1:  eth-ess-2013 rural  823
# 2:  eth-ess-2013 urban 1747
# 3: eth-erss-2011 rural 1287
# 4: eth-erss-2011 urban  426
# => quite a few rural hhlds missing production and sales data
eth[is.na(totcropprod_kg), uniqueN(hhid), by=.(svyCode, rural)]

# Actually these vars seem to have data, and `shagprodsold` has no NA
eth[, summary(shagprodsold), by=svyCode]
eth[, summary(shcropsold), by=svyCode]


# Verify
par(mfrow=c(1,2))
pplot(cropsales_sh~svyCode, data=eth)
pplot(shcropsold~svyCode, data=eth)
pplot(shagprodsold~svyCode, data=eth)
# But these shares are much lower than `cropsales_sh`, problem with net/gross?

par(mfrow=c(1,3))
pplot(cropsales_sh~svyCode, data=tza)
pplot(shcropsold~svyCode, data=tza)
pplot(shagprodsold~svyCode, data=tza)


##############################################
# STRATIFICATION

# Add geo vars from RIGA
eth.hh <- lapply(eth.f.hh[-1], function(x) data.table(read.dta13(x, generate.factors=T)))

# Harmonize var codes
tmp <- unlist(lapply(eth.hh, names))
tmp <- table(tmp)
names(tmp)[tmp==1]
setnames(eth.hh[[1]], "household_id2", "hhid")
setnames(eth.hh[[2]], "household_id", "hhid")
setnames(eth.hh[[2]], c("LAT_DD_MOD", "LON_DD_MOD"), c("lat_dd_mod", "lon_dd_mod"))

tmp <- unlist(lapply(eth.hh, names))
tmp <- table(tmp)
vars.hh <- names(tmp)[tmp==2]
eth.hh <- lapply(eth.hh, function(x) x[, .SD, .SDcols=vars.hh])
eth.hh <- rbindlist(eth.hh)

# Recodes
setnames(eth.hh, c("dist_road", "dist_market", "ssa_aez09"), c("distroad", "distmarket", "ez"))
# Drop
eth.hh <- eth.hh[, .SD, .SDcols=names(eth.hh) %in% lbl$varCode]

anyDuplicated(eth.hh, by="hhid")
eth[!hhid %in% eth.hh$hhid, .(svyCode, hhid)]
# 52 households with no geo variables?
eth <- eth[, .SD, .SDcols=c("hhid", setdiff(names(eth), names(eth.hh)))]
setkey(eth.hh, hhid)
setkey(eth, hhid)
eth <- eth.hh[eth]

# Add `zone` (`saq02`), Kebele `ward` (`saq06`), and `clust` (ea_id) vars
eth.hh <- lapply(eth.f.xtra[-1], function(x) data.table(read.dta13(x, generate.factors=T)))
setnames(eth.hh[[1]], c("household_id", "household_id2", "ea_id2"), 
  c("y1_hhid", "hhid", "clust"))
setnames(eth.hh[[2]], c("household_id", "ea_id"), c("hhid", "clust"))
eth.hh <- list(
  eth.hh[[1]][, .SD, .SDcols=c("hhid", "saq02", "saq06", "clust")],
  eth.hh[[2]][, .SD, .SDcols=c("hhid", "saq02", "saq06", "clust")]
)
eth.hh <- rbindlist(eth.hh, fill=TRUE)
setnames(eth.hh, c("saq02", "saq06"), c("zone", "ward"))

# Merge into `eth`
eth <- eth[, .SD, .SDcols=c("hhid", setdiff(names(eth), names(eth.hh)))]
setkey(eth.hh, hhid)
setkey(eth, hhid)
eth <- eth.hh[eth]
eth[, summary(zone)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 1.000   2.000   5.000   6.358   9.000  22.000
eth[, summary(ward)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 1.00    3.00    8.00   12.03   15.00  403.00
eth[, unique(district), by=zone]
#  Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 1.000   2.000   4.000   5.571   8.000  25.000

###############################################
# ETH-ERSS-2011 `region_cd`, `zone`, `zone_cd`
# Region and Zone codes/labels are available in the doco, Woreda and Kebele are not present
tmp <- fread("~/Data/ETH-ERSS-11/raw/eth-erss-11_geo-labels.csv")
tmp[, svyCode := "eth-erss-2011"]
# Fix typos
levels(eth$region) <- c("Tigray", "Afar", "Amhara", "Oromiya", "Somali", 
  "Benshangul Gumuz", "SNNP", "Gambella", "Harari", "Addis Ababa", "Dire Dawa")
# Merge region codes into `eth`
setkey(eth, svyCode, region)
setkey(tmp, svyCode, reglabel)
eth[tmp, region_cd := i.regcode]
eth[svyCode=="eth-erss-2011", .N, by=.(svyCode, is.na(region_cd))]
#          svyCode is.na    N
# 1: eth-erss-2011 FALSE 3969

# Merge zone labels into `eth`
setnames(eth, "zone", "zone_cd")
setkey(tmp, svyCode, regcode, zonecode)
setkey(eth, svyCode, region_cd, zone_cd)
eth[tmp, zone := i.zonelabel]
eth[svyCode=="eth-erss-2011", .N, by=.(svyCode, is.na(zone))]

# TODO ETH-ESS-2013 `region_cd` (`saq01`), `zone`, `zone_cd` (`saq02`)
eth[svyCode=="eth-ess-2013", .N, by=.(region, region_cd, zone, zone_cd)]
tmp <- data.table(read.dta("~/Data/ETH-ESS-13/raw/sect_cover_hh_w2.dta"))
tmp[, svyCode := "eth-ess-2013"]

# Merge region/zone codes into `eth`
setkey(eth, svyCode, hhid)
setkey(tmp, svyCode, household_id2)
eth[tmp, `:=`(region_cd = i.saq01, zone_cd = i.saq02)]
eth[svyCode=="eth-ess-2013", .N, by=.(svyCode, is.na(region_cd))]
#         svyCode is.na    N
# 1: eth-ess-2013 FALSE 5128

# Merge zone labels into `eth`
# There are new zones in the ESS, we need those labels as well from the doco
tmp <- fread("~/Data/ETH-ESS-13/raw/eth-ess-13_geo-labels.csv")
tmp[, svyCode := "eth-ess-2013"]
tmp[, range(zonecode), by=reglabel]
eth[, range(zone_cd), by=region]
setkey(tmp, svyCode, reglabel, zonecode)
setkey(eth, svyCode, region, zone_cd)
eth[tmp, zone := i.zonelabel]
eth[svyCode=="eth-ess-2013", .N, by=.(svyCode, is.na(zone))]


# TODO bring in woreda and kebele labels
setnames(eth, c("district", "ward"), c("district_cd", "ward_cd"))
# Pull `svyL1*` and `svyL2*` from existing maps
levels(g2.dt$svyCode) <- c("tza-nps-2012", "eth-ess-2013", "eth-erss-2011",
  "gha-glss6", "gha-glss5")
g2.dt[svyCode=="eth-ess-2013", .N, by=svyL2Nm]
# => 79 districts
g2.dt[svyCode=="eth-ess-2013", range(svyL2Cd)]
# [1]    0 1501
g2.dt[svyCode=="eth-erss-2011", .N, by=svyL2Nm]
# => 702 districts
g2.dt[svyCode=="eth-erss-2011", range(svyL2Cd)]
# [1]  10101 508061


###############################################
# Sampling `strata`
# Rep for rural and small town areas in the most populous regions (Amhara, Oromiya,
# SNNP, and Tigray). The sample is not representative for each of the small regions
# including Afar, Benshangul Gumuz, Dire Dawa, Gambella, Harari, and Somalie regions.
# However, estimates can be produced for a combination of all smaller regions as one
# “other region” category. Note that "large towns" sampling frame was added to 2013/14
# panel
tmp <- data.table(read.dta("~/Data/ETH-ESS-13/raw/sect_cover_hh_w2.dta"))
tmp[, svyCode := "eth-ess-2013"]
setkey(tmp, svyCode, household_id2)
setkey(eth, svyCode, hhid)
eth[tmp, rural := i.rural]
eth[, res := rural]
levels(eth$res)
eth[, .N, keyby=.(svyCode, res)]
#          svyCode                res    N
# 1: eth-erss-2011              rural 3466
# 2: eth-erss-2011              urban  503
# 3:  eth-ess-2013              Rural 3211
# 4:  eth-ess-2013 Small town (urban)  444
# 5:  eth-ess-2013 Large town (urban) 1473
levels(eth$res) <- c("rural", "urban", "rural", "urban - small town", "urban - large town")
levels(eth$rural) <- c("rural", "urban", "rural", "urban", "urban")

eth[, strata := region]
levels(eth$strata) 
levels(eth$strata) <- c("Tigray", "other regions", "Amhara", "Oromiya", "other regions", 
  "other regions", "SNNP", "other regions", "other regions", "Addis Ababa", "other regions")
eth[, strata := factor(strata, levels=levels(strata)[c(6,1,3:5,2)])]
setorder(eth, strata, res)
# => note that strata needs to be combined with `res` for actual sampling frames
eth[, strata := paste0(as.character(strata), " (", res, ")")]
eth[, strata := factor(strata, levels=unique(strata))]
# Also add `survey` for printing and tables
eth[, survey := factor(svyCode, levels=c("eth-ess-2015", "eth-ess-2013", "eth-erss-2011"))]
levels(eth$survey) <- c("2015/16", "2013/14", "2011/12")

# Map household across strata to verify
eth.pts <- SpatialPointsDataFrame(eth[!is.na(lon_dd_mod), .(lon_dd_mod, lat_dd_mod)], 
  data.frame(eth[!is.na(lon_dd_mod), .(survey, wave, svyCode, hhid, strata, region, district_cd, ward)]),
  proj4string=CRS("+init=epsg:4326"))


###############################################
# PANEL/POPULATION WEIGHTS `phhid`, `pweight`, `pcount`
# Hhld mapping is present in wave 3
eth.panel <- data.table(read.dta(eth.f.xtra[2]))
eth[, `:=`(y1_hhid=NULL, y2_hhid=NULL, phhid=NULL, pweight=NULL, pcount=NULL)]
# Remove empty strings
eth.panel[, `:=`(
  y1_hhid = ifelse(household_id=="", NA, household_id),
  y2_hhid = ifelse(household_id2=="", NA, household_id2)
)]

setkey(eth, hhid)
setkey(eth.panel, y1_hhid)
eth[eth.panel, `:=`(y1_hhid = i.y1_hhid, y2_hhid = i.y2_hhid)]
setkey(eth.panel, y2_hhid)
eth[eth.panel, `:=`(y1_hhid = i.y1_hhid, y2_hhid = i.y2_hhid)]

# Verify
eth[svyCode=="eth-erss-2011" & is.na(y1_hhid), y1_hhid := hhid]
eth[svyCode=="eth-ess-2013" & is.na(y2_hhid), y2_hhid := hhid]
eth[, phhid := .GRP, keyby=.(y1_hhid, y2_hhid)]
eth[, pcount := .N, by=phhid]
dcast(eth, svyCode~pcount)
#          svyCode    1    2
# 1: eth-erss-2011  314 3655
# 2:  eth-ess-2013 1473 3655

# TODO Bring in or compute adjusted panel weights
# Not clear if `pw_w3` is adjusted for panels


###############################################
# QUADRANTS
# Merge raster values into `eth`
wb[, range(hhid), keyby=svyCode]
#          svyCode                 V1
# 1: eth-erss-2011     01010101601002
# 2: eth-erss-2011     15010203102121
# 3:  eth-ess-2013 010101088801601002
# 4:  eth-ess-2013 150102088803102121
# 5:  eth-ess-2015 010101088801601002
# 6:  eth-ess-2015 150102088803102121
setkey(eth, svyCode, hhid)
setkey(wb, svyCode, hhid)
eth[, `:=`(cell5m=NULL, suit_gaez=NULL)]
eth[wb, `:=`(
  cell5m = hc_seq_5m,
  suit_gaez = res03_crav6190l_silr_cer
  )]

# Verify
eth[, .N, by=.(svyCode, is.na(cell5m))]
eth[, .N, by=.(svyCode, is.na(suit_gaez))]
# 7 missing in eth-ess-2013
eth[is.na(cell5m), .(hhid, lat_dd_mod, lon_dd_mod)]

# Let's plot those points
tmp <- eth[is.na(cell5m) & !is.na(lat_dd_mod), hhid]
tmap_mode("view")
qtm(eth.pts[eth.pts$hhid %in% tmp,])
# => there's no reason they should be missing, less impute values from the same `clust`
eth[, `:=`(
  cell5m_imp = modal(cell5m, na.rm=T),
  suit_gaez_imp = modal(suit_gaez, na.rm=T)
  ), by=.(svyCode, clust)]
eth[is.na(cell5m), cell5m := cell5m_imp]
eth[is.na(suit_gaez), suit_gaez := suit_gaez_imp]
eth[, `:=`(cell5m_imp=NULL, suit_gaez_imp=NULL)]

# Plot to verify
eth.pts <- SpatialPointsDataFrame(eth[!is.na(lat_dd_mod), .(lon_dd_mod, lat_dd_mod)], 
  data.frame(eth[!is.na(lat_dd_mod), 
    .(hhid, svyCode, survey, wave, strata, region, district_cd, cell5m, suit_gaez)]))
qtm(eth.pts, symbols.col="cell5m")


# Merge in HarvestChoice travel times `tt20k_mean`
# Load CELL5M
load("~/Projects/hc-cell5m/rdb/2016.03/cell5m.rda")
dt <- dt[, .SD, .SDcols=c("CELL5M", names(dt)[names(dt) %like% "tt10_"])]
setnames(dt, 2:6, c("tt20k_mean", "tt50k_mean", "tt100k_mean", "tt250k_mean", "tt500k_mean"))
setkey(dt, CELL5M)
setkey(eth, cell5m)
eth <- dt[eth]
rm(dt)
summary(eth$tt100k_mean)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 0.2251  2.5602  3.9945  4.3897  5.6089 20.5380
setnames(eth, "CELL5M", "cell5m")

# Classify GAEZ suitability into `seg_suit_gaez` (agpot-hi, agpot-lo, agpot-no)
# GAEZ suitability is coded from 1 to 9:
# 0-no data, 1-very high (> 85%), 2-high (> 70%), 3-good (> 55%), 4-medium (> 40%), 
# 5-moderate (> 25%), 6-marginal (> 10%), 7-very marginal (> 0%), 8-not suitable (0%), 9-water
eth[suit_gaez %between% c(1,4), seg_suit_gaez := "agpot-hi"]
eth[suit_gaez %between% c(5,7), seg_suit_gaez := "agpot-lo"]
eth[suit_gaez %between% c(8,9), seg_suit_gaez := "agpot-no"]
eth[, seg_suit_gaez := factor(seg_suit_gaez, levels=c("agpot-hi", "agpot-lo", "agpot-no"))]
eth[, .N, keyby=.(svyCode, seg_suit_gaez)]
# Note there is no suit_gaez==0 but there are missing values 

# Encode `suit_gaez` labels
eth[, suit_gaez := factor(suit_gaez, levels=0:9, 
  labels=c(
    "0-no data", "1-very high (> 85%)", "2-high (> 70%)", 
    "3-good (> 55%)", "4-medium (> 40%)", "5-moderate (> 25%)", 
    "6-marginal (> 10%)", "7-very marginal (> 0%)", "8-not suitable (0%)", "9-water"))]

# Classify market access into `seg_mkt20k` (mkt-lo, mkt-hi) using 4hr cutoff 
eth[, `:=`(
  seg_mkt20k = factor(tt20k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt50k = factor(tt50k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt100k = factor(tt100k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt250k = factor(tt250k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi")),
  seg_mkt500k = factor(tt500k_mean <= 4, levels=c(FALSE, TRUE), labels=c("mkt-lo", "mkt-hi"))
)]
eth[, .N, keyby=.(svyCode, seg_mkt100k)]

# Make quadrants `seg_quad` using 100K market size
# (agpot-lo / mkt-lo, agpot-lo / mkt-hi, agpot-hi / mkt-lo, agpot-hi / mkt-hi)
eth[, seg_quad := factor(paste(seg_suit_gaez, seg_mkt100k, sep=" / "))]
# Arbitrarily classify seg_mkt100k==NA into "mkt-lo"
# Arbitrarily classify seg_suit_gaez==NA and seg_suit_gaez="agpot-no" into "agpot-lo"
levels(eth$seg_quad)
levels(eth$seg_quad) <- c(
  "agpot-hi / mkt-hi", "agpot-hi / mkt-lo", "agpot-lo / mkt-hi", "agpot-lo / mkt-lo",
  "agpot-lo / mkt-hi", "agpot-lo / mkt-lo")
# Reorder levels
eth[, seg_quad := factor(seg_quad, levels=quad)]
table(eth$seg_quad)
# agpot-lo / mkt-lo agpot-lo / mkt-hi agpot-hi / mkt-lo agpot-hi / mkt-hi 
#              3352              2715              1130              1900 

# Verify visually
eth.pts <- SpatialPointsDataFrame(eth[!is.na(lat_dd_mod), .(lon_dd_mod, lat_dd_mod)], 
  data.frame(eth[!is.na(lat_dd_mod), 
    .(hhid, svyCode, survey, wave, strata, region, district_cd, cell5m, suit_gaez,
      seg_suit_gaez, seg_mkt100k, seg_quad)]))
tm_shape(rquad) + tm_raster(pal=viridis(4), breaks=0:4, labels=quad, alpha=.6) +
  tm_shape(eth.pts, is.master=T) + tm_dots("seg_quad", pal=viridis(4))
# => looks OK


###############################################
# TODO FARM MANAGEMENT
# Include IFPRI recodes (last wave only unfortunately)
ifpri[, .N, by=svyCode]
# => only has data for eth-erss-2011



```



```{r gha-typo, eval=FALSE}

# Done in `2017-agra-aasr` but might need revisions

##########################################
# CROP SALES
# Options #1 `totcropsold`
gha[, summary(totcropsold)] 
gha[, median(totcropsold, na.rm=T), by=croparea_3clas]
#    croparea_clas   V1
# 1:            NA    0
# 2:       <= 2 ha  270
# 3:        2-4 ha 1240
# 4:        > 4 ha 3883
# => seems land consistent
gha[, cropsales := totcropsold]
gha[, cropsales_sh := cropsales / cropvalue]
gha[, summary(cropsales_sh)]
#  Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 0.000   0.000   0.254   0.336   0.601   1.000   15411 
gha[cropsales_sh > 0, .N, by=svyCode]
# Option #2 `shcropsold` (might have been imputed by RIGA)
gha[, summary(shcropsold)]
#  Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 0.000   0.000   0.102   0.273   0.529   1.000   11260 
gha[shcropsold > 0, .N, by=svyCode]
#      svyCode    N
# 1: gha-glss6 5485
# 2: gha-glss5 3272
# 3: gha-glss4 2904
gha[, cropsales_sh := shcropsold]

##########################################
# AG SALES
gha[, summary(shagprodsold)]
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 0.0000  0.0000  0.0000  0.1998  0.3545  1.0000     310 
# => probably just more 0
gha[, agsales := totagsold]
gha[, agsales_sh := totagsold / totagprod]
# More positive obs if using `shagprodsold`
gha[, agsales_sh := shagprodsold]

pplot(cropsales_sh~survey+croparea_4ha, gha)
pplot(agsales_sh~survey+croparea_4ha, gha)


##########################################
# SHF 4ha dummy `croparea_4ha` (2-class)
gha[, croparea_4ha := NULL]
gha[croparea_imp>0, croparea_4ha := factor(croparea_imp <= 4, levels=c(T, F), labels=c("<= 4 ha", "> 4 ha"))]
summary(gha$croparea_4ha)
# <= 4 ha  > 4 ha    NA's 
#   15587    3312   12558 

##########################################
# Crop commercialization dummy `cropsales_3clas`
gha[, cropsales_3clas := NULL]
gha[, cropsales_3clas := cut(cropsales_sh, c(-1,.05,.5,1.1), labels=c("LoC", "MeC", "HiC"), ordered=T, right=F)]
summary(gha$cropsales_3clas)
#  LoC   MeC   HiC  NA's 
# 9288  5579  5330 11260 
# => there's a big difference in the number of NA's

##########################################
# Ag commercialization dummy `agsales_3clas`
gha[, agsales_3clas := NULL]
gha[, agsales_3clas := cut(agsales_sh, c(-1,.05,.5,1.1), labels=c("LoC", "MeC", "HiC"), ordered=T, right=F)]
summary(gha$agsales_3clas)
#   LoC   MeC   HiC  NA's 
# 18750  6452  5945   310 
# => there's a big difference in the number of NA's

##########################################
# Income diversification dummy `naggross_3clas`
gha[, naggross_3clas := NULL]
gha[, naggross_3clas := cut(naggross_sh, c(-1,1/3,2/3,1.1), labels=c("LoD", "MeD", "HiD"), ordered=T, right=F)]
summary(gha$naggross_3clas)
#   LoD   MeD   HiD  NA's 
# 10549  1934 16268  2706 

##########################################
# Income diversification dummy `noaggross_2clas`
gha[, naggross_2clas := NULL]
gha[, naggross_2clas := cut(naggross_sh, c(-1,1/3,1.1), labels=c("LoD", "HiD"), ordered=T, right=F)]
summary(gha$naggross_2clas)
#   LoD  HiD   NA's 
# 10549 18202  2706 

##########################################
# Farm classification dummy `class9`
class9 <- c("LoCLoD", "LoCMeD", "LoCHiD",  "MeCLoD", "MeCMeD", "MeCHiD", 
  "HiCLoD", "HiCMeD", "HiCHiD")
gha[, class9 := NULL]
gha[, class9 := factor(paste0(agsales_3clas, naggross_3clas), levels=class9)]
summary(gha$class9)
# LoCLoD LoCMeD LoCHiD MeCLoD MeCMeD MeCHiD HiCLoD HiCMeD HiCHiD   NA's 
#   2400    500  13454   4387    752   1313   3762    682   1501   2706 

##########################################
# Classification dummy `class6`
class6 <- c("LoCLoD", "LoCHiD",  "MeCLoD", "MeCHiD", "HiCLoD", "HiCHiD")
gha[, class6 := NULL]
gha[, class6 := factor(paste0(agsales_3clas, naggross_2clas), levels=class6)]
summary(gha$class6)
# LoCLoD LoCHiD MeCLoD MeCHiD HiCLoD HiCHiD   NA's 
#   2400  13954   4387   2065   3762   2183   2706

##########################################
# Farm classification dummy `class5`
gha[, class5 := class6]
levels(gha$class5) <- c("subs.", "trans.", "pre-comm.", "trans.", "specd. comm.", "divf. comm.")
summary(gha$class5)
# subs.       trans.    pre-comm. specd. comm.  divf. comm.         NA's 
# 2400        16019         4387         3762         2183         2706 

```


```{r tza-typo, eval=FALSE}

##################################################################################### 
# TZA Farm Typology 
#####################################################################################

# CULTIVATED AREA
# Settle for using RIGA operated area instead (we added landrent+landlend, didn't
# seem consistent)
# TODO Construct cultivated area from Ag module
pplot(landown~survey, data=tza, ylim=c(0,10))
pplot(landrent~survey, data=tza, ylim=c(0,10))
tza[, .N, by=.(wave, pos=landown-landrent>=0)]
tza[, summary(landown), by=.(wave, totagprod>0)]
tza[, summary(totagprod), by=.(wave, landown>0)]
tza[totagprod>0 & is.na(landown), .N, by=wave]
# Empty data.table (0 rows) of 2 cols: wave,N
tza[totagprod>0 & (landown==0 & landrent==0), .N, by=wave]
#      wave   N
# 1: wave 3 447
# 2: wave 2 316
# 3: wave 1 361
tza[shagprodsold>0 & (landown==0 & landrent==0), .N, by=wave]
#      wave   N
# 1: wave 3 243
# 2: wave 2 152
# 3: wave 1 188
# There are NAs in landown, but most hhlds with any agprod have land

tza[, croparea := NULL]
#tza[, croparea := rowSums(.SD[, .(landown, -landrent)], na.rm=T)]
tza[, croparea := rowSums(.SD[, .(landown)], na.rm=T)]
tza[, 100*sum(croparea > 0 & croparea <= 4, na.rm=T)/.N, by=.(wave, rural)]
#     wave rural       V1
# 1: wave 3 rural 53.96262
# 2: wave 3 urban 13.28125
# 3: wave 2 rural 65.18460
# 4: wave 2 urban 24.96413
# 5: wave 1 rural 78.15085
# 6: wave 1 urban 20.66667

# There are 908 hlds with some crop production but no land
# I'm tempted to impute `croparea` in those cases
tza[totcropprod>0, .N, by=.(wave, croparea>0)]

# What is the median crop production per ha per survey/region. Use that to impute `croparea`.
tza[, croparea_imp := croparea]
tza[, qtl := cut(totcropprod, 
  unique(quantile(totcropprod, seq(0,1,.2), na.rm=T)), include.lowest=T),
  by=svyCode]
tza[, q := median(ifelse(croparea==0, NA, croparea), na.rm=T),  by=.(svyCode, qtl)]
tza[totcropprod>0 & (is.na(croparea_imp) | croparea_imp==0), croparea_imp := q]
tza[totcropprod>0, .N, by=.(wave, croparea_imp>0)]

tza[shagprodsold>0, .N, by=.(wave, croparea_imp>0)]
# There are still 105 hlds with some `shagprodsold` but no land (in all 3 surveys)
# Impute `croparea` again
tza[, qtl := cut(shagprodsold, 
  unique(quantile(shagprodsold, seq(0,1,.2), na.rm=T)), include.lowest=T),
  by=svyCode]
tza[, q := median(ifelse(croparea==0, NA, croparea), na.rm=T),  by=.(svyCode, qtl)]
tza[shagprodsold>0 & (is.na(croparea_imp) | croparea_imp==0), croparea_imp := q]
tza[shagprodsold>0, .N, by=.(wave, croparea_imp>0)]

# Clean up
tza[, `:=`(qtl=NULL, q=NULL)]

##########################################
# SHF 4ha dummy `croparea_4ha` (2-class)
tza[, croparea_4ha := NULL]
tza[croparea_imp>0, croparea_4ha := factor(croparea_imp <= 4, levels=c(T, F), labels=c("<= 4 ha", "> 4 ha"))]
summary(tza$croparea_4ha)
# <= 4 ha  > 4 ha    NA's 
#    7240     926    3997 

##########################################
# SHF 4ha dummy `croparea_3clas`
tza[, croparea_3clas := NULL]
tza[, max(croparea, na.rm=T)]
tza[croparea_imp>0, croparea_3clas := cut(croparea_imp, c(-1,2,4,51), labels=c("<= 2 ha", "2-4 ha", "> 4 ha"), ordered=T, right=F)]
summary(tza$croparea_3clas)
# <= 2 ha  2-4 ha  > 4 ha    NA's 
#    5750    1490     926    3997 


##########################################
# CROP PRODUCTION
summary(tza$totcropprod)
tza[, sum(is.na(totcropprod)), by=svyCode]
tza[, sum(is.na(shagprodsold)), by=svyCode]
tza[, median(totcropprod, na.rm=T), keyby=croparea_3clas]
# => some hhlds have no/missing land but some crop production
#    croparea_3clas        V1
# 1:             NA       0.0
# 2:        <= 2 ha  338083.3
# 3:         2-4 ha  775080.0
# 4:         > 4 ha 1135056.0
tza[, cropvalue := totcropprod]
tza[, 100*sum(cropvalue>0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural       V1
# 1: 2012/13 rural 61.15448
# 2: 2012/13 urban  0.00000
# 3: 2010/11 rural 83.24732
# 4: 2010/11 urban  2.51076
# 5: 2008/09 rural 91.14355
# 6: 2008/09 urban 24.66667

##########################################
# CROP SALES
tza[, summary(totcropsold)]
tza[, summary(shcropsold)]
tza[, median(totcropsold, na.rm=T), keyby=croparea_3clas]
#    croparea_3clas     V1
# 1:             NA      0
# 2:        <= 2 ha  28000
# 3:         2-4 ha 193750
# 4:         > 4 ha 322500
# => seems land consistent
tza[, cropsales := totcropsold]
tza[, cropsales_sh := shcropsold]
tza[, summary(cropsales_sh)]
tza[, 100*sum(cropsales_sh>0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural        V1
# 1: 2012/13 rural 45.682517
# 2: 2012/13 urban  0.000000
# 3: 2010/11 rural 61.254466
# 4: 2010/11 urban  1.291248
# 5: 2008/09 rural 67.639903
# 6: 2008/09 urban 13.000000

##########################################
# AG SALES
tza[, summary(totagsold)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
#    0       0   48000  267700  270000 7646000    3188 
tza[, summary(shagprodsold)]
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 0.0000  0.0000  0.0000  0.1608  0.2468  1.0000 
tza[, agsales := totagsold]
tza[, agsales_sh := shagprodsold]

tza[, 100*sum(agsales_sh>0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural       V1
# 1: 2012/13 rural 51.14739
# 2: 2012/13 urban  0.00000
# 3: 2010/11 rural 68.32076
# 4: 2010/11 urban  2.15208
# 5: 2008/09 rural 77.42092
# 6: 2008/09 urban 18.66667

##########################################
# GROSS FARM INCOME
tza[, summary(farmrntimp)]
tza[, summary(agr_wge)]
tza[, summary(selfimp1)]
# => ignore `selfimp1` for now
tza[, aggross := rowSums(.SD[, .(totagprod, farmrntimp, agr_wge, ifelse(selfimp1 < 0, NA, selfimp1))], na.rm=T)]
tza[, 100*sum(aggross>0, na.rm=T)/.N, by=.(survey, rural)]

# GROSS NON-FARM INCOME
tza[, summary(transfersgrossimp)]
tza[, summary(otherincimp)]
tza[, summary(nonfarmrntimp)]
tza[, summary(nonagr_wge)]
tza[, summary(selfemp)]
boxplot(selfemp~svyCode, tza)
tza[, naggross := rowSums(.SD[, .(transfersgrossimp, otherincimp, nonfarmrntimp, nonagr_wge, ifelse(selfemp < 0, NA, selfemp))], na.rm=T)]
tza[, totgross := rowSums(.SD[, .(aggross, naggross)], na.rm=T)]
tza[, naggross_sh := naggross/totgross]
tza[, 100*sum(naggross_sh>0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural       V1
# 1: 2012/13 urban 97.91667
# 2: 2012/13 rural 87.29595
# 3: 2010/11 rural 83.04883
# 4: 2008/09 rural 77.56691
# 5: 2010/11 urban 95.26542
# 6: 2008/09 urban 93.00000

tza[, sum(cropsales_sh > 0, na.rm=T), keyby=croparea_3clas]
tza[, sum(aggross > 0, na.rm=T), keyby=croparea_3clas]
# some `aggross` with no land
tza[, sum(naggross_sh > 0, na.rm=T), keyby=croparea_3clas]

# HHlds with ag share but no/na aggross?
tza[shagprodsold>0, .N, by=aggross>0]
#    aggross     N
# 1:    TRUE  5728
# => OK

# Other internal consistency checks
# HHlds with crop share but no/null croparea?
tza[, sum(shcropsold>0, na.rm=T), keyby=croparea_3clas]
#    croparea_3clas   V1
# 1:             NA    0
# 2:        <= 2 ha 3178
# 3:         2-4 ha 1127
# 4:         > 4 ha  733
# => OK

pplot(cropsales_sh~survey+croparea_4ha, tza)
pplot(agsales_sh~survey+croparea_4ha, tza)
# => `cropsales_sh` shares seem to make more sense, but `agsales_sh` has much fewer NAs...

##########################################
# Crop commercialization dummy `cropsales_3clas`
tza[, cropsales_3clas := NULL]
tza[, cropsales_3clas := cut(cropsales_sh, c(-1,.05,.5,1.1), labels=c("LoC", "MeC", "HiC"), ordered=T, right=F)]
summary(tza$cropsales_3clas)
#  LoC  MeC  HiC NA's 
# 4380 2884 1711 3188 

##########################################
# Ag commercialization dummy `agsales_3clas`
tza[, agsales_3clas := NULL]
tza[, agsales_3clas := cut(agsales_sh, c(-1,.05,.5,1.1), labels=c("LoC", "MeC", "HiC"), ordered=T, right=F)]
summary(tza$agsales_3clas)
#  LoC  MeC  HiC 
# 7112 3591 1460 

##########################################
# Income diversification dummy `naggross_3clas`
tza[, naggross_3clas := NULL]
tza[, naggross_3clas := cut(naggross_sh, c(-1,1/3,2/3,1.1), labels=c("LoD", "MeD", "HiD"), ordered=T, right=F)]
summary(tza$naggross_3clas)
#  LoD  MeD  HiD NA's 
# 4603 1415 5945  200 

##########################################
# Income diversification dummy `noaggross_2clas`
tza[, naggross_2clas := NULL]
tza[, naggross_2clas := cut(naggross_sh, c(-1,1/3,1.1), labels=c("LoD", "HiD"), ordered=T, right=F)]
summary(tza$naggross_2clas)
#  LoD  HiD NA's 
# 4603 7360  200

##########################################
# Farm classification dummy `class9`
class9 <- c("LoCLoD", "LoCMeD", "LoCHiD",  "MeCLoD", "MeCMeD", "MeCHiD", 
  "HiCLoD", "HiCMeD", "HiCHiD")
tza[, class9 := NULL]
tza[, class9 := factor(paste0(cropsales_3clas, naggross_3clas), levels=class9)]
summary(tza$class9)
# LoCLoD LoCMeD LoCHiD MeCLoD MeCMeD MeCHiD HiCLoD HiCMeD HiCHiD   NA's 
#   1384    522   2377   2105    518    261   1043    330    338   3285 

##########################################
# Classification dummy `class6`
class6 <- c("LoCLoD", "LoCHiD",  "MeCLoD", "MeCHiD", "HiCLoD", "HiCHiD")
tza[, class6 := NULL]
tza[, class6 := factor(paste0(cropsales_3clas, naggross_2clas), levels=class6)]
summary(tza$class6)
# LoCLoD LoCHiD MeCLoD MeCHiD HiCLoD HiCHiD   NA's 
#   1384   2899   2105    779   1043    668   3285

##########################################
# Farm classification dummy `class5`
tza[, class5 := class6]
levels(tza$class5) <- c("subs.", "trans.", "pre-comm.", "trans.", "specd. comm.", "divf. comm.")
summary(tza$class5)
# subs.       trans.    pre-comm. specd. comm.  divf. comm.         NA's 
#  1384         3678         2105         1043          668         3285


```

```{r eth-typo, eval=FALSE}

# CULTIVATED AREA
# TODO Construct cultivated area from Ag module
pplot(landown~survey, data=eth, ylim=c(0,10))
pplot(landrent~survey, data=eth, ylim=c(0,10))
eth[, .N, by=.(wave, pos=landown-landrent >= 0)]
eth[totcropprod_kg > 0 & is.na(landown), .N, by=wave]
# Empty data.table (0 rows) of 2 cols: wave,N
eth[totcropprod_kg > 0 & (landown==0 & landrent==0), .N, by=wave]
#      wave   N
# 1: wave 2 153
# 2: wave 1 208
eth[cropsales_sh > 0 & (landown==0 & landrent==0), .N, by=wave]
#      wave   N
# 1: wave 2  97
# 2: wave 1 149
# There are NAs in landown, but most hhlds with any cropprod have land

eth[, croparea := rowSums(cbind(landown, landrent), na.rm=T)]
eth[, 100*sum(croparea > 0 & croparea <= 4, na.rm=T)/.N, by=.(wave, rural)]

# There are hlds with some crop production but no land
# I'm tempted to impute `croparea` in those cases
eth[totcropprod_kg > 0, .N, by=.(wave, croparea > 0)]

# What is the median crop production per ha per survey/region. Use that to impute `croparea`.
eth[, croparea_imp := croparea]
eth[, qtl := cut(totcropprod_kg, 
  unique(quantile(totcropprod_kg, seq(0,1,.2), na.rm=T)), include.lowest=T),
  by=svyCode]
eth[, q := median(ifelse(croparea==0, NA, croparea), na.rm=T),  by=.(svyCode, qtl)]
eth[totcropprod_kg > 0 & (is.na(croparea_imp) | croparea_imp==0), croparea_imp := q]

# Verify
eth[totcropprod_kg > 0, .N, by=.(wave, croparea_imp > 0)]
eth[cropsales_sh > 0, .N, by=.(wave, croparea_imp > 0)]

# Clean up
eth[, `:=`(qtl=NULL, q=NULL)]

##########################################
# SHF 4ha dummy `croparea_4ha` (2-class)
eth[, croparea_4ha := NULL]
eth[croparea_imp > 0, croparea_4ha := factor(croparea_imp <= 4, levels=c(T, F), labels=c("<= 4 ha", "> 4 ha"))]
summary(eth$croparea_4ha)
# <= 4 ha  > 4 ha    NA's 
#    5999      80    3018 

##########################################
# SHF 4ha dummy `croparea_3clas`
eth[, croparea_3clas := NULL]
eth[, max(croparea, na.rm=T)]
eth[croparea_imp > 0, croparea_3clas := cut(croparea_imp, c(-1,2,4,51), labels=c("<= 2 ha", "2-4 ha", "> 4 ha"), ordered=T, right=F)]
summary(eth$croparea_3clas)
# <= 2 ha  2-4 ha  > 4 ha    NA's 
#    5404     595      80    3018 


##########################################
# CROP SALES
# Computed from raw data (higher shares than recorded in RIGA, but lots of NAs)
eth[, summary(shcropsold)]
eth[, summary(cropsales_sh)]
eth[, 100*sum(shcropsold > 0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural        V1
# 1: 2013/14 rural 44.409841
# 2: 2013/14 urban  2.869066
# 3: 2011/12 rural 30.929025
# 4: 2011/12 urban  5.168986
eth[, 100*sum(cropsales_sh > 0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural        V1
# 1: 2013/14 rural 62.254749
# 2: 2013/14 urban  4.225352
# 3: 2011/12 rural 51.298327
# 4: 2011/12 urban  6.759443

##########################################
# AG SALES
eth[, summary(totagsold)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#    0       0     100    1459    1600  173977
eth[, summary(shagprodsold)]
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 0.00000 0.00000 0.01362 0.11132 0.15076 1.00000  

eth[, agsales := totagsold]
eth[, agsales_sh := shagprodsold]
eth[, 100*sum(agsales_sh>0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural       V1
# 1: 2013/14 rural 78.82280
# 2: 2013/14 urban 10.90245
# 3: 2011/12 rural 63.18523
# 4: 2011/12 urban 14.71173


##########################################
# GROSS FARM INCOME
eth[, summary(totagprod)]
eth[, summary(farmrntimp)]
eth[, summary(agr_wge)]
eth[, summary(selfimp1)]
# => ignore `selfimp1` for now
eth[, aggross := rowSums(.SD[, .(totagprod, farmrntimp, agr_wge, ifelse(selfimp1 < 0, NA, selfimp1))], na.rm=T)]
eth[, 100*sum(aggross>0, na.rm=T)/.N, by=.(survey, rural)]

# GROSS NON-FARM INCOME
eth[, summary(transfersgrossimp)]
eth[, summary(otherincimp)]
eth[, summary(nonfarmrntimp)]
eth[, summary(nonagr_wge)]
eth[, summary(selfemp)]
boxplot(selfemp~svyCode, eth)
eth[, naggross := rowSums(.SD[, .(transfersgrossimp, otherincimp, nonfarmrntimp, nonagr_wge, ifelse(selfemp < 0, NA, selfemp))], na.rm=T)]
eth[, totgross := rowSums(.SD[, .(aggross, naggross)], na.rm=T)]
eth[, naggross_sh := naggross/totgross]
eth[, 100*sum(naggross_sh>0, na.rm=T)/.N, by=.(survey, rural)]
#     survey rural       V1
# 1: 2013/14 rural 51.82186
# 2: 2013/14 urban 91.23631
# 3: 2011/12 rural 45.26832
# 4: 2011/12 urban 84.09543

eth[, sum(cropsales_sh > 0, na.rm=T), keyby=croparea_3clas]
eth[, sum(aggross > 0, na.rm=T), keyby=croparea_3clas]
# some `aggross` with no land
eth[, sum(naggross_sh > 0, na.rm=T), keyby=croparea_3clas]

# HHlds with ag share but no/na aggross?
eth[shagprodsold>0, .N, by=aggross>0]
#    aggross     N
# 1:    TRUE  5004
# => OK

# Other internal consistency checks
# HHlds with crop share but no/null croparea?
eth[, sum(shcropsold>0, na.rm=T), keyby=croparea_3clas]
#    croparea_3clas   V1
# 1:             NA    0
# 2:        <= 2 ha 3178
# 3:         2-4 ha 1127
# 4:         > 4 ha  733
# => OK

pplot(shcropsold~survey+croparea_4ha, eth)
pplot(cropsales_sh~survey+croparea_4ha, eth)
pplot(cropsales_sh~survey+croparea_4ha, tza)
pplot(agsales_sh~survey+croparea_4ha, eth)
# => `cropsales_sh` shares derived from KG seem to make more sense, but `agsales_sh` has much fewer NAs...
# NOTE `cropsales_sh` is NOT derived from RIGA but from raw production/sales volumes
# we might need to adust results from TZA accordingly

##########################################
# Crop commercialization dummy `cropsales_3clas`
eth[, cropsales_3clas := NULL]
eth[, cropsales_3clas := cut(cropsales_sh, c(-1,.05,.5,1.1), labels=c("LoC", "MeC", "HiC"), ordered=T, right=F)]
summary(eth$cropsales_3clas)
#  LoC  MeC  HiC NA's 
# 1062 2319 1417 4299

##########################################
# Ag commercialization dummy `agsales_3clas`
eth[, agsales_3clas := NULL]
eth[, agsales_3clas := cut(agsales_sh, c(-1,.05,.5,1.1), labels=c("LoC", "MeC", "HiC"), ordered=T, right=F)]
summary(eth$agsales_3clas)
#  LoC  MeC  HiC 
# 5406 3213  478 

##########################################
# Income diversification dummy `naggross_3clas`
eth[, naggross_3clas := NULL]
eth[, naggross_3clas := cut(naggross_sh, c(-1,1/3,2/3,1.1), labels=c("LoD", "MeD", "HiD"), ordered=T, right=F)]
summary(eth$naggross_3clas)
#  LoD  MeD  HiD NA's 
# 5746  691 2425  235 

##########################################
# Income diversification dummy `noaggross_2clas`
eth[, naggross_2clas := NULL]
eth[, naggross_2clas := cut(naggross_sh, c(-1,1/3,1.1), labels=c("LoD", "HiD"), ordered=T, right=F)]
summary(eth$naggross_2clas)
#  LoD  HiD NA's 
# 5746 3116  235

##########################################
# Farm classification dummy `class9`
eth[, class9 := NULL]
eth[, class9 := factor(paste0(cropsales_3clas, naggross_3clas), levels=class9)]
summary(eth$class9)
# LoCLoD LoCMeD LoCHiD MeCLoD MeCMeD MeCHiD HiCLoD HiCMeD HiCHiD   NA's 
#    820    106    126   2100    147     63   1249     95     52   4339 

##########################################
# Classification dummy `class6`
eth[, class6 := NULL]
eth[, class6 := factor(paste0(cropsales_3clas, naggross_2clas), levels=class6)]
summary(eth$class6)
# LoCLoD LoCHiD MeCLoD MeCHiD HiCLoD HiCHiD   NA's 
#    820    232   2100    210   1249    147   4339

##########################################
# Farm classification dummy `class5`
eth[, class5 := class6]
levels(eth$class5) <- c("subs.", "trans.", "pre-comm.", "trans.", "specd. comm.", "divf. comm.")
Summary(eth$class5)
# subs.       trans.    pre-comm. specd. comm.  divf. comm.         NA's 
#   820          442         2100         1249          147         4339 

```

```{r gha-table, eval=FALSE}

# Need to generate results by wave, class5, rural, farm sizes, and margins
gha.table <- 
  # by wave
  lapply(gha.svy.farm[1:2], function(x) {
    # by farm size
    lapply(levels(gha$croparea_4ha), function(i) {
      svyCrossTab(list(
        
        # Demographics
        ~hhsize_imp, ~agehead, ~I(100*femhead), ~I(100*widowhead), ~hhlabor,
        ~educhead, ~educave15_60, ~educhigh,
        ~I(100*ownhome), ~I(100*cellphone), ~I(100*telephone), ~I(100*electricity), 
        ~distwater, ~distroad, ~distpost, ~distbank, ~disthealth,
        # Land
        ~landown, ~landshare, ~croparea_imp,
        #~landrent,
        # Income
        ~aggross, ~totgross, ~I(100*naggross_sh), ~cropvalue, ~cropsales,
        ~I(100*cropsales_sh), ~totlvstprod, ~totlivsold,
        # Livestock
        ~I(1E3*TLU_horse), ~I(1E3*TLU_cattle), ~I(1E3*TLU_pigs), ~I(1E3*TLU_sheep),
        ~I(1E3*TLU_small), ~I(1E3*TLU_total), 
        # Input
        ~I(100*seeds), ~I(100*fert_any), ~I(100*fert_inorg), ~I(100*fert_org), 
        ~I(100*herb), ~I(100*pest), ~I(100*irr), ~I(100*fuel), ~I(100*hired_labor)
        
      ), ~class5, subset(x, croparea_4ha==i), quantiles=c(.5, .9))
    })
  })

gha.table.rur <- 
  # by wave
  lapply(gha.svy.farm[1:2], function(x) {
    # by rural
    lapply(levels(gha$rural), function(r) {
      svyCrossTab(list(
        
        # Demographics
        ~hhsize_imp, ~agehead, ~I(100*femhead), ~I(100*widowhead), ~hhlabor,
        ~educhead, ~educave15_60, ~educhigh,
        ~I(100*ownhome), ~I(100*cellphone), ~I(100*telephone), ~I(100*electricity), 
        ~distwater, ~distroad, ~distpost, ~distbank, ~disthealth,
        # Land
        ~landown, ~landshare, ~croparea_imp,
        #~landrent,
        # Income
        ~aggross, ~totgross, ~I(100*naggross_sh), ~cropvalue, ~cropsales,
        ~I(100*cropsales_sh), ~totlvstprod, ~totlivsold,
        # Livestock
        ~I(1E3*TLU_horse), ~I(1E3*TLU_cattle), ~I(1E3*TLU_pigs), ~I(1E3*TLU_sheep),
        ~I(1E3*TLU_small), ~I(1E3*TLU_total), 
        # Input
        ~I(100*seeds), ~I(100*fert_any), ~I(100*fert_inorg), ~I(100*fert_org), 
        ~I(100*herb), ~I(100*pest), ~I(100*irr), ~I(100*fuel), ~I(100*hired_labor)
        
      ), ~class5, subset(x, rural==r), quantiles=c(.5, .9))
    })
  })


    

```


```{r designs, eval=FALSE}

#####################################################################################
# Define Stratified Survey Designs
#####################################################################################
# GHA
gha.svy <- list(
  `gha6` = svydesign(~clust+hhid, strata=~region+rural, w=~weight, nest=T,
    data=gha[survey=="2012/13"]),
  `gha5` =  svydesign(~clust+hhid, strata=~region+rural, w=~weight, nest=T,
    data=gha[survey=="2005/06"]),  
  `gha4` = svydesign(~clust+hhid, strata=~rural, w=~weight, nest=T,
    data=gha[survey=="1998/99"])
)

# Subset survey sample to farms
gha.svy.farm <- lapply(gha.svy, subset, !is.na(croparea_3clas))

# Subset survey sample to SHF (note that they exclude farms with no `croparea`)
gha.svy.shf <- lapply(gha.svy, subset, croparea_4ha=="<= 4 ha")

###############################################
# TZA
tza.svy <- list(
  `tza3` = svydesign(~clust+hhid, strata=~strata, w=~weight, nest=T,
    data=tza[survey=="2012/13"]),
  `tza2` =  svydesign(~clust+hhid, strata=~strata, w=~weight, nest=T,
    data=tza[survey=="2010/11"]),  
  `tza1` = svydesign(~clust+hhid, strata=~strata, w=~weight, nest=T,
    data=tza[survey=="2008/09"])
)

tza.svy.farm <- lapply(tza.svy, subset, !is.na(croparea_3clas))
tza.svy.shf <- lapply(tza.svy, subset, croparea_4ha=="<= 4 ha")


###############################################
# ETH
eth.svy <- list(
  # `eth3` = svydesign(~clust+hhid, strata=~strata, w=~weight, nest=T,
  #   data=eth[survey=="2015/16"]),
  `eth2` =  svydesign(~clust+hhid, strata=~strata, w=~weight, nest=T,
    data=eth[survey=="2013/14"]),  
  `eth1` = svydesign(~clust+hhid, strata=~strata, w=~weight, nest=T,
    data=eth[survey=="2011/12"])
)

eth.svy.farm <- lapply(eth.svy, subset, !is.na(croparea_3clas))
eth.svy.shf <- lapply(eth.svy, subset, croparea_4ha=="<= 4 ha")

```

```{r save, eval=FALSE}

rm(tmp, tmp1, tmp2, x, y, i, j, tza.adm, tza.chr, tza.inc, tza.hh, 
  eth.adm, eth.chr, eth.inc, eth.hh, tmp.cv)
save.image("./tmp/2017-ispc.RData")

#####################################################################################
# Export Harmonized Panel Datasets
#####################################################################################
# GHA
names(gha)[!names(gha) %in% lbl$varCode]
tmp <- lbl[varCode %in% names(gha)]
setorder(tmp, secOrder, sortOrder)
tmp <- tmp$varCode
setcolorder(gha, c(tmp, setdiff(names(gha), tmp)))
setkey(lbl, varCode)

gha %>%
  setorder(svyCode, hhid) %>%
  setattr("var.labels", lbl[names(gha), paste0(varLabel, " (", unit, ")")]) %>%
  setattr("datalabel", "Prepared by BACOU, Melanie <mel@mbacou.com> for BMGF") %>%
  write.dta("./out/gha-glss_merged_2017.11.08.dta", version=12L, convert.factors="labels")


###############################################
# TZA
setdiff(names(tza), lbl$varCode)
tmp <- lbl[varCode %in% names(tza)]
setorder(tmp, secOrder, sortOrder)
tmp <- tmp$varCode
setcolorder(tza, c(tmp, setdiff(names(tza), tmp)))
setkey(lbl, varCode)

tza %>%
  setorder(svyCode, hhid) %>%
  setattr("var.labels", lbl[names(tza), paste0(varLabel, " (", unit, ")")]) %>%
  setattr("datalabel", "Prepared by BACOU, Melanie <mel@mbacou.com> for BMGF") %>%
  write.dta("./out/tza-nps_merged_2017.11.08.dta", version=12L, convert.factors="labels")


###############################################
# ETH
setdiff(names(eth), lbl$varCode)
tmp <- lbl[varCode %in% names(eth)]
setorder(tmp, secOrder, sortOrder)
tmp <- tmp$varCode
setcolorder(eth, c(tmp, setdiff(names(eth), tmp)))
setkey(lbl, varCode)

eth %>%
  setorder(svyCode, hhid) %>%
  setattr("var.labels", lbl[names(eth), paste0(varLabel, " (", unit, ")")]) %>%
  setattr("datalabel", "Prepared by BACOU, Melanie <mel@mbacou.com> for BMGF") %>%
  write.dta("./out/eth-ess_merged_2017.11.16.dta", version=12L, convert.factors="labels")


```

## Harmonized Codebook

This study combines household-level micro data for 4 countries across multiple survey years. To expedite data reconciliation steps we choose to rely as much as possible on [FAO RIGA-H cross-country harmonized household-level database](http://www.fao.org/economic/riga/riga-database/en/). RIGA expenditure and income aggregates are used to estimate both farm and crop sales and farm vs. non-farm income. We also include additional household-level variables available through [IFPRI replication datasets](https://dataverse.harvard.edu/dataverse/harvestchoice). Below is a full codebook.


```{r prep, results="asis"}

setorder(lbl, secOrder, sortOrder)
for (i in unique(lbl$section)) {
  print(htmltools::h3(tools::toTitleCase(i)))
  print(kable(lbl[section==i, .SD, .SDcols=4:7], "html", 
    col.names=c("Variable", "Label", "Unit", "Source")))
}

```

## RIGA Income Aggregates

Notes on RIGA variable construction (see @riga2007doco for a complete documentation):

- All aggregates are estimated at the household level.  
- All income and expenditures are **annualized**.  
- All income components are **net of costs**.  
- Purchases and sales of **durable goods**, investments and windfall gains are excluded from household income and expenditure calculations since these are not transactions undertaken regularly by households and can result in the significant over- or under-stating of permanent income.  
- All aggregates are reported in **local currency (LCU)**.  
- For each survey, only the **rural** sample is used (this does not seem consistent across all surveys)  
- An outlier check is imposed after the construction of all income aggregates to deal with extreme income shares that arise following the aggregation of all income components. After estimating the shares of the seven principal income categories (agricultural wages, non-agricultural wages, crop, livestock, self employment, transfer and other) **observations with shares greater than or less than 3 (indicating a percentage share of +/- 300%) are dropped from the aggregate**.  

However because RIGA income aggregates are *net of costs*, we construct intermediary components:

- $cropsales$ is derived/imputed from RIGA $totcropsold$
- $cropvalue$ is derived/imputed from RIGA $totcropprod$
- $cropsales\_sh$ (but can also be derived from RIGA $totcropsold$, $shcropsold$, or $shagprodsold$)
  $$ cropsales\_sh = \frac{cropsales}{cropvalue} $$ 
- $agsales$ is derived/imputed from RIGA $totagsold$
- $agsales\_sh$
  $$ agsales\_sh = \frac{agsales}{totagprod} $$
- $aggross = totagprod + farmrntimp + agr\_wge (+ selfimp1)$
- $naggross = transfersgrossimp + otherincimp + nonfarmrntimp + nonagr\_wge + selfemp$
- $totgross = aggross + naggross$  
- $aggross\_sh$  
  $$ aggross\_sh = \frac{aggross}{totgross} $$  

RIGA-H does not provide annual cultivated area, instead we have measures of land owned, land rented out, and land under sharecropping.

## Survey Maps

In addition to reconciling household-level micro data, we also construct (approximate) district-level administrative maps for all survey waves. Survey maps and household variables may be linked using attributes `svyCode`, `svyL1Cd`, and `svyL2Cd` (the combination of these 3 attributes always identifies a unique district). The current maps are:

```{r maps}

kable(g2.dt[, .(
  Regions=uniqueN(svyL1Cd),
  Districts=uniqueN(paste(svyL1Nm, svyL2Nm))), 
  keyby=.(Survey=svyCode)],
  caption="Constructed Survey Maps (in progress)")

```

## Agricultural Potential Quadrants

In the delineation of farm segments we construct areas of high and low agricultural potential. These areas are obtained by combining areas of high/low agricultural suitability (FAO/GAEZ 2007) with high/low market access (IFPRI 2016). These input maps and the resulting quadrants are shown here.

```{r maps-suit, fig.cap="Agricultural Suitability (FAO/GAEZ 2007)", out.width="99%"}

i <- c("eth-erss-2011", "gha-glss6", "tza-nps-2012")

tm_shape(rgaez) + tm_raster(n=9, pal=qd.agpot.lbl$col, labels=qd.agpot.lbl$code,
  title="Agricultural\nSuitability") +
  tm_shape(g2[g2$svyCode %in% i,], is.master=T) + tm_borders(alpha=.1) +
  tm_facets("ISO3", ncol=3, free.coords=T)

```

```{r maps-tt100k, fig.cap="Market Access (100K market size, IFPRI 2016)", out.width="99%"}

tm_shape(rtt100k) + tm_raster(breaks=c(0,.5,1,2,4,6,8,12,88),
  title="Travel\nTime\n(100K, hrs)") +
  tm_shape(g2[g2$svyCode %in% i,], is.master=T) + tm_borders(alpha=.1) +
  tm_facets("ISO3", ncol=3, free.coords=T)

```

```{r maps-quad, fig.cap="Low/High Agricultural Potential Quadrants", out.width="99%"}

tm_shape(rquad) + tm_raster(pal=viridis(4), n=4, labels=quad,
  title="Agricultural\nPotential\nQuadrants") +
  tm_shape(g2[g2$svyCode %in% i,], is.master=T) + tm_borders(alpha=.1) +
  tm_facets("ISO3", ncol=3, free.coords=T)

```
